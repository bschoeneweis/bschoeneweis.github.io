{"pageProps":{"tag":"pandas","taggedPosts":[{"id":"forecasting-spy-prices","contentHtml":"<h2>tl;dr</h2>\n<h3>Goal</h3>\n<p><em>To apply Facebook's Prophet forecasting procedure to historical SPY (SPDR S&#x26;P 500 ETF Trust) market data to gather future pricing predictions.</em></p>\n<h3>A few notes</h3>\n<ul>\n<li>I'm by no means a data scientist, so this is more of an exploratory analysis than an accurate one</li>\n<li>For sake of brevity, I won't be using a training/test split or measuring the error of the model, I will just train the model on the entire dataset and then make a prediction</li>\n</ul>\n<h3>Process overview</h3>\n<ol>\n<li><strong>Downloading the data</strong> - exporting the data from Yahoo Finance as a CSV</li>\n<li><strong>Exploring the data</strong> - loading and exploring the data using Pandas</li>\n<li><strong>Fitting the model</strong> - reading in the data and applying a basic fit of the Prophet model to the data</li>\n<li><strong>Visualizing the forecast</strong> - visualizing the forecasted pricing data</li>\n</ol>\n<h3>Python dependencies</h3>\n<pre><code>import pandas as pd\nfrom prophet import Prophet\n</code></pre>\n<hr>\n<p>Before we jump in, let's give a little background on SPY and on Facebook's Prophet.</p>\n<p>The <em>SPDR S&#x26;P 500 ETF Trust</em> (SPY) is an ETF (<em>Exchange Traded Fund</em>) that tracks the performance of the S&#x26;P 500 index.  SPY is also the largest ETF in the world, and is popular compared to other ETFs that track the S&#x26;P 500 because of the high volume, or the number of shares that trade on a given day (we'll be able to see the volume per day in the CSV we export from Yahoo Finance).</p>\n<p>For more information on ETFs, <a href=\"https://www.investopedia.com/terms/e/etf.asp\">Investopedia gives a good overview</a>.</p>\n<p><a href=\"https://facebook.github.io/prophet/\">Facebook Prophet</a> is an open source, automated forecasting procedure for time series data.  I'm not going to dive too much into the mathematics or implementation details of Prophet, but if you are more interested, you can read the <a href=\"https://peerj.com/preprints/3190/\">research paper</a>.  Prophet makes it easy to handle outliers, adjust to different time intervals, deal with holidays, and leaves the ability to easily tune the forecasting model.</p>\n<p>Now that we have a general idea of what we're trying to predict and the tool we'll use to forecast, let's dive into the actual data.</p>\n<hr>\n<h2>Downloading the data</h2>\n<p>Thanks to Yahoo Finance, we can download historical pricing data for free. You can click <a href=\"https://finance.yahoo.com/quote/SPY/history?p=SPY\">here</a> to view the SPY historical pricing data.</p>\n<p>Click on the <code>Historical Data</code> tab, and then we can adjust our <code>Time Period</code> to the Max as seen below (back to January 1993).</p>\n<p><img src=\"/images/forecasting-spy/export-data.jpg\" alt=\"Historical pricing data {priority}{680x243}\"></p>\n<p>Now we can click download to get our CSV and start diving into the data.</p>\n<hr>\n<h2>Exploring the data</h2>\n<p>Let's fire up Pandas and load our data into a DataFrame to see what general insights we can extract.</p>\n<pre><code>df = pd.read_csv('SPY.csv')\n\n# Columns and row count\ndf.info()\n\"\"\"\n&#x3C;class 'pandas.core.frame.DataFrame'>\nRangeIndex: 7125 entries, 0 to 7124\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   Date       7125 non-null   object \n 1   Open       7125 non-null   float64\n 2   High       7125 non-null   float64\n 3   Low        7125 non-null   float64\n 4   Close      7125 non-null   float64\n 5   Adj Close  7125 non-null   float64\n 6   Volume     7125 non-null   int64  \ndtypes: float64(5), int64(1), object(1)\nmemory usage: 389.8+ KB\n\"\"\"\n\n# Preview of the data\ndf.head()\n\"\"\"\n         Date      Open      High       Low     Close  Adj Close   Volume\n0  1993-01-29  43.96875  43.96875  43.75000  43.93750  25.884184  1003200\n1  1993-02-01  43.96875  44.25000  43.96875  44.25000  26.068277   480500\n2  1993-02-02  44.21875  44.37500  44.12500  44.34375  26.123499   201300\n3  1993-02-03  44.40625  44.84375  44.37500  44.81250  26.399649   529400\n4  1993-02-04  44.96875  45.09375  44.46875  45.00000  26.510111   531500\n\"\"\"\n\n# General statistics\ndf.describe().loc[['mean', 'min', 'max']]\n\"\"\"\n            Open        High         Low       Close   Adj Close        Volume\nmean  146.896395  147.766581  145.928716  146.896373  121.611954  8.453727e+07\nmin    43.343750   43.531250   42.812500   43.406250   25.571209  5.200000e+03\nmax   422.500000  422.820007  419.160004  422.119995  422.119995  8.710263e+08\n\"\"\"\n\n# Day to day percent changes of Highs\ndf[['Date', 'High']].set_index('Date').pct_change().reset_index()\n\"\"\"\n            Date      High\n0     1993-01-29       NaN\n1     1993-02-01  0.006397\n2     1993-02-02  0.002825\n3     1993-02-03  0.010563\n4     1993-02-04  0.005575\n         ...       ...\n7120  2021-05-10 -0.000189\n7121  2021-05-11 -0.017670\n7122  2021-05-12 -0.006454\n7123  2021-05-13 -0.000582\n7124  2021-05-14  0.012465\n\n[7125 rows x 2 columns]\n\"\"\"\n</code></pre>\n<p>Now that we know a bit more about our data in general, we can create a model using Prophet.</p>\n<hr>\n<h2>Fitting the model</h2>\n<p>Since we're not concerned in this post about making our model the best it can be, we can train our model on the entire dataset.</p>\n<p>This typically isn't a good practice.  When trying to make an accurate prediction, you should use training and test subsets of the data and calculate errors within your model and use those results to tune hyperparameters.</p>\n<p>Nevertheless, let's continue.</p>\n<pre><code># The prophet model fits to a DataFrame with a date column (ds)\n# and a value to predict (y)\ndf_predict = df[['Date', 'Close']]\ndf_predict.columns = ['ds', 'y']\n\n# We can find all of the missing days within our dataset\n# and mark those as \"holidays\"\ndate_series = pd.to_datetime(df['Date'])\ndf_missing_dates = pd\\\n    .date_range(start=date_series.min(), end=date_series.max())\\\n    .difference(date_series)\\\n    .to_frame()\\\n    .reset_index()\ndf_missing_dates.columns = ['holiday', 'ds']\ndf_missing_dates['holiday'] = 'Stock Market Closed'\n\n# Fitting our model is incredibly simple and can be done in the\n# most basic sense in just two lines of code\nm = Prophet(daily_seasonality=True, holidays=df_missing_dates)\nm.fit(df_predict)\n</code></pre>\n<p>Just like that, we have built our model for a forecast.  All we have left to do is generate dates to predict values for, and run the actual prediction.</p>\n<hr>\n<h2>Visualizing the forecast</h2>\n<p>Now let's forecast with our model and visualize the results.</p>\n<pre><code># Create a DataFrame with past and future dates (only weekdays)\nfuture = m.make_future_dataframe(periods=365)\nfuture = future[pd.to_datetime(future['ds']).dt.weekday &#x3C; 5]\n\n# Now we can forecast and visualize in just two more lines of code\nforecast = m.predict(future)\nm.plot(forecast, xlabel='Date', ylabel='Daily Closing Price')\n</code></pre>\n<p><img src=\"/images/forecasting-spy/first-prediction.jpg\" alt=\"First SPY forecast {800x480}\"></p>\n<blockquote>\n<p><strong>A few things to notice</strong></p>\n<ul>\n<li>The black dots are the training data points</li>\n<li>The blue outline is the confidence interval</li>\n<li>The line within the confidence interval is the actual forecast</li>\n</ul>\n</blockquote>\n<p>Based on our results, we can see the forecast is fairly linear and the confidence interval is relatively narrow (due to the volume of date).  The behavior of the stock market since Covid-19 started back around February 2020 has be a little unorthodox, so let's narrow our model to be trained back to data starting in 2017 to see if there is an effect.</p>\n<pre><code># Narrow down to start at 2017\ndf_recent_predict = df_predict.iloc[date_series[date_series.dt.year > 2016].index]\ndate_series = pd.to_datetime(df_recent_predict['ds'])\ndf_recent_missing_dates =  pd\\\n    .date_range(start=date_series.min(), end=date_series.max())\\\n    .difference(date_series)\\\n    .to_frame()\\\n    .reset_index()\ndf_recent_missing_dates.columns = ['holiday', 'ds']\ndf_recent_missing_dates['holiday'] = 'Stock Market Closed'\n\n# Create and fit our new model\nm = Prophet(daily_seasonality=True, holidays=df_recent_missing_dates)\nm.fit(df_recent_predict)\n\n# Recreate our future predictions\nfuture = m.make_future_dataframe(periods=365)\nfuture = future[pd.to_datetime(future['ds']).dt.weekday &#x3C; 5]\n\n# Forecast and visualize\nforecast = m.predict(future)\nm.plot(forecast, xlabel='Date', ylabel='Daily Closing Price')\n</code></pre>\n<p><img src=\"/images/forecasting-spy/second-prediction.jpg\" alt=\"Second SPY forecast {800x480}\"></p>\n<p>Now we can see a much wider confidence interval and a bit more of a bumpy forecast line; however, this looks much more realistic in terms of stock market prediction.</p>\n<hr>\n<h2>Conclusion</h2>\n<p>All in all, Facebook's Prophet is a very fast, impressive, and strongly abstracted library.  The entire script, including reading in the data, training and forecasting two models, and plotting both of the forecasts took right around <strong>25 seconds</strong>.</p>\n<p>I would love to see this tool in the hands of an actual data scientist to see the accuracy of the models they'd be able to create using Prophet.</p>\n<hr>\n","markdown":"\n## tl;dr\n\n### Goal\n_To apply Facebook's Prophet forecasting procedure to historical SPY (SPDR S&P 500 ETF Trust) market data to gather future pricing predictions._\n\n### A few notes\n- I'm by no means a data scientist, so this is more of an exploratory analysis than an accurate one\n- For sake of brevity, I won't be using a training/test split or measuring the error of the model, I will just train the model on the entire dataset and then make a prediction\n\n### Process overview\n1. **Downloading the data** - exporting the data from Yahoo Finance as a CSV\n2. **Exploring the data** - loading and exploring the data using Pandas\n3. **Fitting the model** - reading in the data and applying a basic fit of the Prophet model to the data\n4. **Visualizing the forecast** - visualizing the forecasted pricing data\n\n### Python dependencies\n```python\nimport pandas as pd\nfrom prophet import Prophet\n```\n\n<p style=\"background-color: orange; padding: 7px 20px; border-radius: 6px;\">\n    <b>Important</b> This article is not investment advice, please conduct your own due diligence. This is merely a simple analysis.\n</p>\n\n---\n\nBefore we jump in, let's give a little background on SPY and on Facebook's Prophet.\n\nThe _SPDR S&P 500 ETF Trust_ (SPY) is an ETF (_Exchange Traded Fund_) that tracks the performance of the S&P 500 index.  SPY is also the largest ETF in the world, and is popular compared to other ETFs that track the S&P 500 because of the high volume, or the number of shares that trade on a given day (we'll be able to see the volume per day in the CSV we export from Yahoo Finance).\n\nFor more information on ETFs, [Investopedia gives a good overview](https://www.investopedia.com/terms/e/etf.asp).\n\n[Facebook Prophet](https://facebook.github.io/prophet/) is an open source, automated forecasting procedure for time series data.  I'm not going to dive too much into the mathematics or implementation details of Prophet, but if you are more interested, you can read the [research paper](https://peerj.com/preprints/3190/).  Prophet makes it easy to handle outliers, adjust to different time intervals, deal with holidays, and leaves the ability to easily tune the forecasting model.\n\nNow that we have a general idea of what we're trying to predict and the tool we'll use to forecast, let's dive into the actual data.\n\n---\n\n## Downloading the data\nThanks to Yahoo Finance, we can download historical pricing data for free. You can click [here](https://finance.yahoo.com/quote/SPY/history?p=SPY) to view the SPY historical pricing data.\n\nClick on the `Historical Data` tab, and then we can adjust our `Time Period` to the Max as seen below (back to January 1993).\n\n![Historical pricing data {priority}{680x243}](/images/forecasting-spy/export-data.jpg)\n\nNow we can click download to get our CSV and start diving into the data.\n\n---\n\n## Exploring the data\nLet's fire up Pandas and load our data into a DataFrame to see what general insights we can extract.\n\n```python\ndf = pd.read_csv('SPY.csv')\n\n# Columns and row count\ndf.info()\n\"\"\"\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 7125 entries, 0 to 7124\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   Date       7125 non-null   object \n 1   Open       7125 non-null   float64\n 2   High       7125 non-null   float64\n 3   Low        7125 non-null   float64\n 4   Close      7125 non-null   float64\n 5   Adj Close  7125 non-null   float64\n 6   Volume     7125 non-null   int64  \ndtypes: float64(5), int64(1), object(1)\nmemory usage: 389.8+ KB\n\"\"\"\n\n# Preview of the data\ndf.head()\n\"\"\"\n         Date      Open      High       Low     Close  Adj Close   Volume\n0  1993-01-29  43.96875  43.96875  43.75000  43.93750  25.884184  1003200\n1  1993-02-01  43.96875  44.25000  43.96875  44.25000  26.068277   480500\n2  1993-02-02  44.21875  44.37500  44.12500  44.34375  26.123499   201300\n3  1993-02-03  44.40625  44.84375  44.37500  44.81250  26.399649   529400\n4  1993-02-04  44.96875  45.09375  44.46875  45.00000  26.510111   531500\n\"\"\"\n\n# General statistics\ndf.describe().loc[['mean', 'min', 'max']]\n\"\"\"\n            Open        High         Low       Close   Adj Close        Volume\nmean  146.896395  147.766581  145.928716  146.896373  121.611954  8.453727e+07\nmin    43.343750   43.531250   42.812500   43.406250   25.571209  5.200000e+03\nmax   422.500000  422.820007  419.160004  422.119995  422.119995  8.710263e+08\n\"\"\"\n\n# Day to day percent changes of Highs\ndf[['Date', 'High']].set_index('Date').pct_change().reset_index()\n\"\"\"\n            Date      High\n0     1993-01-29       NaN\n1     1993-02-01  0.006397\n2     1993-02-02  0.002825\n3     1993-02-03  0.010563\n4     1993-02-04  0.005575\n         ...       ...\n7120  2021-05-10 -0.000189\n7121  2021-05-11 -0.017670\n7122  2021-05-12 -0.006454\n7123  2021-05-13 -0.000582\n7124  2021-05-14  0.012465\n\n[7125 rows x 2 columns]\n\"\"\"\n```\n\nNow that we know a bit more about our data in general, we can create a model using Prophet.\n\n---\n\n## Fitting the model\n\nSince we're not concerned in this post about making our model the best it can be, we can train our model on the entire dataset.\n\nThis typically isn't a good practice.  When trying to make an accurate prediction, you should use training and test subsets of the data and calculate errors within your model and use those results to tune hyperparameters.\n\nNevertheless, let's continue.\n\n```python\n# The prophet model fits to a DataFrame with a date column (ds)\n# and a value to predict (y)\ndf_predict = df[['Date', 'Close']]\ndf_predict.columns = ['ds', 'y']\n\n# We can find all of the missing days within our dataset\n# and mark those as \"holidays\"\ndate_series = pd.to_datetime(df['Date'])\ndf_missing_dates = pd\\\n    .date_range(start=date_series.min(), end=date_series.max())\\\n    .difference(date_series)\\\n    .to_frame()\\\n    .reset_index()\ndf_missing_dates.columns = ['holiday', 'ds']\ndf_missing_dates['holiday'] = 'Stock Market Closed'\n\n# Fitting our model is incredibly simple and can be done in the\n# most basic sense in just two lines of code\nm = Prophet(daily_seasonality=True, holidays=df_missing_dates)\nm.fit(df_predict)\n```\n\nJust like that, we have built our model for a forecast.  All we have left to do is generate dates to predict values for, and run the actual prediction.\n\n---\n\n## Visualizing the forecast\nNow let's forecast with our model and visualize the results.\n\n```python\n# Create a DataFrame with past and future dates (only weekdays)\nfuture = m.make_future_dataframe(periods=365)\nfuture = future[pd.to_datetime(future['ds']).dt.weekday < 5]\n\n# Now we can forecast and visualize in just two more lines of code\nforecast = m.predict(future)\nm.plot(forecast, xlabel='Date', ylabel='Daily Closing Price')\n```\n\n![First SPY forecast {800x480}](/images/forecasting-spy/first-prediction.jpg)\n\n> **A few things to notice**\n> - The black dots are the training data points\n> - The blue outline is the confidence interval\n> - The line within the confidence interval is the actual forecast\n\nBased on our results, we can see the forecast is fairly linear and the confidence interval is relatively narrow (due to the volume of date).  The behavior of the stock market since Covid-19 started back around February 2020 has be a little unorthodox, so let's narrow our model to be trained back to data starting in 2017 to see if there is an effect.\n\n```python\n# Narrow down to start at 2017\ndf_recent_predict = df_predict.iloc[date_series[date_series.dt.year > 2016].index]\ndate_series = pd.to_datetime(df_recent_predict['ds'])\ndf_recent_missing_dates =  pd\\\n    .date_range(start=date_series.min(), end=date_series.max())\\\n    .difference(date_series)\\\n    .to_frame()\\\n    .reset_index()\ndf_recent_missing_dates.columns = ['holiday', 'ds']\ndf_recent_missing_dates['holiday'] = 'Stock Market Closed'\n\n# Create and fit our new model\nm = Prophet(daily_seasonality=True, holidays=df_recent_missing_dates)\nm.fit(df_recent_predict)\n\n# Recreate our future predictions\nfuture = m.make_future_dataframe(periods=365)\nfuture = future[pd.to_datetime(future['ds']).dt.weekday < 5]\n\n# Forecast and visualize\nforecast = m.predict(future)\nm.plot(forecast, xlabel='Date', ylabel='Daily Closing Price')\n```\n\n![Second SPY forecast {800x480}](/images/forecasting-spy/second-prediction.jpg)\n\nNow we can see a much wider confidence interval and a bit more of a bumpy forecast line; however, this looks much more realistic in terms of stock market prediction.\n\n---\n\n## Conclusion\n\nAll in all, Facebook's Prophet is a very fast, impressive, and strongly abstracted library.  The entire script, including reading in the data, training and forecasting two models, and plotting both of the forecasts took right around **25 seconds**.\n\nI would love to see this tool in the hands of an actual data scientist to see the accuracy of the models they'd be able to create using Prophet.\n\n---\n","title":"Forecasting SPY prices using Facebook's Prophet","date":"2021-05-19","tags":["python","pandas"],"description":"Using Facebookâ€™s Prophet, an open-source, time series forecasting procedure to predict SPY (SPDR S&P 500 ETF Trust) closing prices.","hidden":true},{"id":"visualizing-your-linkedin-connections","contentHtml":"<h2>tl;dr</h2>\n<h3>Goal</h3>\n<p><em>To understand and visualize the companies within my directly connected network on LinkedIn</em></p>\n<h3>Process overview</h3>\n<ol>\n<li><strong>LinkedIn data sources</strong> - retrieving LinkedIn Network data from a \"Get a copy of your data\" CSV export</li>\n<li><strong>Diving into the data</strong> - exploring, cleaning, and aggregating the data with <a href=\"https://pandas.pydata.org/\"><code>Pandas</code></a></li>\n<li><strong>Creating the network</strong> - creating a network graph using <a href=\"https://networkx.org/\"><code>NetworkX</code></a></li>\n<li><strong>Visualization</strong> - visualizing the network with <a href=\"https://pyvis.readthedocs.io/en/latest/\"><code>pyvis</code></a></li>\n<li><strong>Improving the output</strong> - cleaning up the network graph with additional filtering</li>\n</ol>\n<h3>Results</h3>\n<p><em>Hover over the nodes for more details</em></p>\n<ul>\n<li><a href=\"/network/first-nx-graph.html\">The first network graph</a></li>\n<li><a href=\"/network/second-nx-graph.html\">The second (more specific) network graph</a></li>\n</ul>\n<h3>Python dependencies</h3>\n<pre><code># Python standard library\nfrom difflib import get_close_matches\n\n# 3rd party\nimport networkx as nx\nimport pandas as pd\nfrom pyvis.network import Network\n</code></pre>\n<hr>\n<p>Recently, I was exploring <a href=\"https://www.linkedin.com/in/bradley-schoeneweis/\">my LinkedIn</a> network to see what some of my colleagues from high school and undergrad are currently up to.</p>\n<p>As I was scrolling through the connections page, I noticed LinkedIn gives you options to filter and searching with ease, but it doesn't really provide tools to learn about your network as a whole.</p>\n<p>So I decided to see if there was an easy way to export my network data to see what I could do with a few hours of exploring the data.</p>\n<h2>LinkedIn data sources</h2>\n<p>My first thought was to checkout out the <a href=\"https://www.linkedin.com/developers/\">LinkedIn's Developer API</a>.</p>\n<p>Something I do fairly frequently at my current job is integrating various 3rd-party REST APIs into our platform, so I wanted to see all the functionality and possibilities that this API would provide.</p>\n<p>After reading through some documentation, I decided this wasn't a direction I wanted to pursue. Most of their developer products require approval, so I decided to look into other options.</p>\n<p>Another thought I had was to write a quick scraping script to pull down the HTML of my connections page and parse out names and companies, but I assumed there had to be a more simple way to get this data.</p>\n<p>Finally, after a bit of research, I found that there are various \"Get a copy of your data\" reports that you can run within LinkedIn.  In order to get to these reports, you can do the following:</p>\n<ol>\n<li>On the homepage toolbar, click the <strong>Me</strong> dropdown</li>\n<li>Under the <em>Account</em> section, click <strong>Settings &#x26; Privacy</strong></li>\n<li>Click on <strong>Get a copy of your data</strong>, and you can view the various reports</li>\n<li>Select the reports you're interested in, for this, I just checked <strong>Connections</strong></li>\n</ol>\n<p>After requesting the report, it should only take a few minutes before you get an email saying your report is ready for export.</p>\n<h2>Diving into the data</h2>\n<p>To reiterate our goal, we want to get a broad understanding of the companies within the first layer of our network (direct connections). Now, let's load up Python and learn more about this data in this CSV.</p>\n<h3>Reading in the data</h3>\n<p>Once the CSV is downloaded, we can open it up with Pandas and take a look (<em>output will be commented below</em>).</p>\n<pre><code>import pandas as pd\n\n# We want to skip the first three rows because of Notes at the top\ndf = pd.read_csv('Connections.csv', skiprows=3)\n\ndf.columns\n# ['First Name', 'Last Name', 'Email Address', 'Company', 'Position', 'Connected On',]\n\ndf.info()\n\"\"\"\n&#x3C;class 'pandas.core.frame.DataFrame'>\nRangeIndex: 376 entries, 0 to 375\nData columns (total 6 columns):\n #   Column         Non-Null Count  Dtype \n---  ------         --------------  ----- \n 0   First Name     375 non-null    object\n 1   Last Name      375 non-null    object\n 2   Email Address  1 non-null      object\n 3   Company        371 non-null    object\n 4   Position       371 non-null    object\n 5   Connected On   376 non-null    object\ndtypes: object(6)\nmemory usage: 17.8+ KB\n\"\"\"\n</code></pre>\n<p>I won't post the name's of any individuals or full rows to respect the privacy of my connections, but when I searched through the my Connections CSV, I noticed a few initial patterns that would help clean up the data.</p>\n<h3>Cleaning up the data</h3>\n<p>At first glance, the first thing I notice is connections who don't list a current company, so let's get rid of those.</p>\n<pre><code>df = df[df['Company'].notna()].sort_values(by='Company')\n</code></pre>\n<p>After sorting, another thing I noticed was that some of these company names belong to the same company, but the individuals wrote them differently.</p>\n<p>An example of this is <code>'IBM Global Solution Center'</code> and <code>'IBM'</code>; for our purposes, these should both be classified as <code>IBM</code>.</p>\n<p>Let's run through a fuzzy match run using <a href=\"https://docs.python.org/3/library/difflib.html#difflib.get_close_matches\">difflib's <code>get_close_matches</code></a> to try and bucket some of these similar company names.</p>\n<pre><code>from difflib import get_close_matches\n\ncompanies = df['Company'].drop_duplicates()\n\n# cutoff=0.7 is a similarity ranking, and n=10 just takes the top 10 values\nsimilar_companies = {x: get_close_matches(x, companies, n=10, cutoff=0.7)\n                     for x in companies}\n\n# We are only interested in the entries that had another match\nsimilar_companies = {x: [name for name in y if name != x]\n                     for x, y in similar_companies.items() if len(y) > 1}\n</code></pre>\n<p>Now, this solution is not perfect, but it will help draw out some similar companies. You should still run a manual inspection of the data (the IBM example I gave above is one that doesn't show up in the fuzzy match results).</p>\n<p>Based upon the results, let's group together some of the companies that had matches.</p>\n<pre><code>df['Company'] = df['Company'].replace({\n    'KPMG US': similar_companies['KPMG US'],\n    'Self-employed': similar_companies['Self-employed'],\n    'IBM Global Solution Center': 'IBM',\n})\n</code></pre>\n<p>The next thing you may have noticed is that in our <code>similar_companies</code> dictionary, we cleaned up a <code>Self-employed</code> entry.</p>\n<p>To stay aligned with our goal, let's drop these entries, as well as your current company.</p>\n<pre><code>companies_to_drop = ['self employed', 'your current company']\ndf = df[~df['Company'].str.lower().isin(companies_to_drop)]\n</code></pre>\n<h3>Aggregating the data</h3>\n<p>Now that our data is cleaned up a bit, let's aggregate and sum the number of connections for each of the companies.</p>\n<pre><code>df_company_counts = df['Company'].value_counts().reset_index()\ndf_company_counts.columns = ['Company', 'Count']  # For ease of understanding\ndf_company_counts = df_company_counts.sort_values(by='Count', ascending=False)\n</code></pre>\n<h2>Creating the network</h2>\n<p>We have the numbers we want for each company, now let's jump into using <code>NetworkX</code> to recreate a network.</p>\n<p>The first step will be to initialize our graph, and add yourself as the central node, as it is your network.</p>\n<pre><code>import networkx as nx\n\nG = nx.Graph()\nG.add_node('Me')\n</code></pre>\n<p>Then, we'll loop through our <code>df_company_counts</code> DataFrame and add each company as a node.</p>\n<p><em>You'll notice some HTML tags in the title below, this is just to make it more readable for later</em></p>\n<pre><code>for _, row in df_company_counts.iterrows():\n\t# The title will be for more information later on\n    title = '&#x3C;b>{0}&#x3C;/b> ({1})&#x3C;br>&#x3C;hr>Positions:&#x3C;br>'.format(row['Company'],\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\trow['Count'])\n\n    # In addition to the full company name, let's add each position in a\n    # list to see the roles our connections have at these companies\n    position_list = ''.join('&#x3C;li>{}&#x3C;/li>'.format(x)\n    \t\t\t\t\t\tfor x in df[df['Company'] == row['Company']]['Position'])\n    title += '&#x3C;ul>{0}&#x3C;/ul>'.format(position_list)\n\n    # For ease of viewing, limit company names to 15 letters\n    node_name = row['Company']\n    if len(node_name) > 15:\n        node_name = node_name[:15] + '...'\n\n    # Add the node and an edge connection ourself to the new node\n    G.add_node(node_name, weight=row['Count'], size=row['Count'] * 2, title=title)\n    G.add_edge('Me', node_name)\n</code></pre>\n<p>And just like that, we've created our network of connections.</p>\n<h2>Visualization</h2>\n<p>Our network graph is created, so let's get into visualizing the network.</p>\n<p>There are a few options for visualizing networks including <code>matplotlib.pyplot</code>, but I found that <code>pyvis</code> was the easiest to use for several reasons:</p>\n<ul>\n<li><code>pyvis</code> generates an HTML file</li>\n<li>Customization is made very easy</li>\n<li>The graph is interactive by default</li>\n</ul>\n<p>Let's look into generating this HTML file.</p>\n<pre><code>from pyvis.network import Network\n\nnt = Network('100%', '100%', bgcolor='#222222', font_color='white')\nnt.from_nx(G)\nnt.repulsion()  # Spaces out the nodes\nnt.show('nx.html')\n</code></pre>\n<p>And it's that simple! We specify a width and height, optional styling attributes, and then we can generate the network graph visual straight from what we created with NetworkX.</p>\n<p>Now we can see <a href=\"/network/first-nx-graph.html\">the network we generated</a>.</p>\n<p>You can hover over each node to see the total number of connections that work at the respective company, and below is a list of the positions held by your connections.</p>\n<p>As you can see, this is a bit hard to read into since there are a lot of nodes. Try and imagine reading this with +1,000 connections.</p>\n<h2>Improving the output</h2>\n<p>There are a few ways that our network could be narrowed down.</p>\n<p>Being a <em>Software Developer</em>, the thought that first occurred to me was to try and dial in on tech-related companies through known positions titles.</p>\n<p>To do this, I thought of a list of buzzwords/common job titles that I've seen across LinkedIn, and filtered down the initial DataFrame.</p>\n<p>Then, we go through the same process we did in previous sections of generating and displaying the graph.</p>\n<p><em>Again, this is not perfect, but it's a good starting point.</em></p>\n<pre><code># Filter down from a list of popular tech positions\npositions = [\n    'developer', 'engineer', 'ai', 'analytics', 'software', 'cloud', 'cto',\n    'sde', 'sre', 'saas', 'product', 'engineering', 'scientist', 'data',\n]\ndf = df[df['Position'].str.contains('|'.join(positions), case=False)]\ndf_company_counts = df['Company'].value_counts().reset_index()\ndf_company_counts.columns = ['Company', 'Count']\ndf_company_counts = df_company_counts.sort_values(by='Count', ascending=False)\n\n# Re-initialize the graph and add the nodes/edges again\nG = nx.Graph()\nG.add_node('Me')\n\nfor _, row in df_company_counts.iterrows():\n    title = '&#x3C;b>{0}&#x3C;/b> ({1})&#x3C;br>&#x3C;hr>Positions:&#x3C;br>'.format(row['Company'], row['Count'])\n    position_list = ''.join('&#x3C;li>{}&#x3C;/li>'.format(x)\n    \t\t\t\t\t\tfor x in df[df['Company'] == row['Company']]['Position'])\n    title += '&#x3C;ul>{0}&#x3C;/ul>'.format(position_list)\n    node_name = row['Company']\n    if len(node_name) > 15:\n        node_name = node_name[:15] + '...'\n\n    # Since there are less nodes, let's increase the sizes\n    G.add_node(node_name, weight=row['Count'], size=row['Count'] * 5, title=title)\n    G.add_edge('Me', node_name)\n\n# Generate the visualization\nnt = Network('100%', '100%', bgcolor='#222222', font_color='white')\nnt.from_nx(G)\nnt.repulsion()\nnt.show('nx.html')\n</code></pre>\n<p>Now, let's look at the <a href=\"/network/second-nx-graph.html\">updated results</a>.</p>\n<p>Much better! This is more readable and easier to interact with.</p>\n<p>And just like that, we achieved our goal of gaining a broader understanding of the companies in our LinkedIn network.</p>\n<hr>\n<p><strong><em>Possible improvements for those interested</em></strong></p>\n<ul>\n<li>Scraping the profile location of each of your connections to segment by location</li>\n<li>Compiling a list of companies you'd like to work for/are interested in and creating a filtering system</li>\n<li>Researching salary data for positions and gathering average pay by company</li>\n</ul>\n<hr>\n","markdown":"\n## tl;dr\n\n### Goal\n_To understand and visualize the companies within my directly connected network on LinkedIn_\n\n### Process overview\n1. **LinkedIn data sources** - retrieving LinkedIn Network data from a \"Get a copy of your data\" CSV export\n2. **Diving into the data** - exploring, cleaning, and aggregating the data with [`Pandas`](https://pandas.pydata.org/)\n3. **Creating the network** - creating a network graph using [`NetworkX`](https://networkx.org/)\n4. **Visualization** - visualizing the network with [`pyvis`](https://pyvis.readthedocs.io/en/latest/)\n5. **Improving the output** - cleaning up the network graph with additional filtering\n\n### Results\n_Hover over the nodes for more details_\n- [The first network graph](/network/first-nx-graph.html)\n- [The second (more specific) network graph](/network/second-nx-graph.html)\n\n### Python dependencies\n```python\n# Python standard library\nfrom difflib import get_close_matches\n\n# 3rd party\nimport networkx as nx\nimport pandas as pd\nfrom pyvis.network import Network\n```\n\n---\n\nRecently, I was exploring [my LinkedIn](https://www.linkedin.com/in/bradley-schoeneweis/) network to see what some of my colleagues from high school and undergrad are currently up to.\n\nAs I was scrolling through the connections page, I noticed LinkedIn gives you options to filter and searching with ease, but it doesn't really provide tools to learn about your network as a whole.\n\nSo I decided to see if there was an easy way to export my network data to see what I could do with a few hours of exploring the data.\n\n\n## LinkedIn data sources\n\nMy first thought was to checkout out the [LinkedIn's Developer API](https://www.linkedin.com/developers/).\n\nSomething I do fairly frequently at my current job is integrating various 3rd-party REST APIs into our platform, so I wanted to see all the functionality and possibilities that this API would provide.\n\nAfter reading through some documentation, I decided this wasn't a direction I wanted to pursue. Most of their developer products require approval, so I decided to look into other options.\n\nAnother thought I had was to write a quick scraping script to pull down the HTML of my connections page and parse out names and companies, but I assumed there had to be a more simple way to get this data.\n\nFinally, after a bit of research, I found that there are various \"Get a copy of your data\" reports that you can run within LinkedIn.  In order to get to these reports, you can do the following:\n1. On the homepage toolbar, click the **Me** dropdown\n2. Under the _Account_ section, click **Settings & Privacy**\n3. Click on **Get a copy of your data**, and you can view the various reports\n4. Select the reports you're interested in, for this, I just checked **Connections**\n\nAfter requesting the report, it should only take a few minutes before you get an email saying your report is ready for export.\n\n\n## Diving into the data\n\nTo reiterate our goal, we want to get a broad understanding of the companies within the first layer of our network (direct connections). Now, let's load up Python and learn more about this data in this CSV.\n\n### Reading in the data\nOnce the CSV is downloaded, we can open it up with Pandas and take a look (_output will be commented below_).\n\n```python\nimport pandas as pd\n\n# We want to skip the first three rows because of Notes at the top\ndf = pd.read_csv('Connections.csv', skiprows=3)\n\ndf.columns\n# ['First Name', 'Last Name', 'Email Address', 'Company', 'Position', 'Connected On',]\n\ndf.info()\n\"\"\"\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 376 entries, 0 to 375\nData columns (total 6 columns):\n #   Column         Non-Null Count  Dtype \n---  ------         --------------  ----- \n 0   First Name     375 non-null    object\n 1   Last Name      375 non-null    object\n 2   Email Address  1 non-null      object\n 3   Company        371 non-null    object\n 4   Position       371 non-null    object\n 5   Connected On   376 non-null    object\ndtypes: object(6)\nmemory usage: 17.8+ KB\n\"\"\"\n```\n\nI won't post the name's of any individuals or full rows to respect the privacy of my connections, but when I searched through the my Connections CSV, I noticed a few initial patterns that would help clean up the data.\n\n### Cleaning up the data\n\nAt first glance, the first thing I notice is connections who don't list a current company, so let's get rid of those.\n\n```python\ndf = df[df['Company'].notna()].sort_values(by='Company')\n```\n\nAfter sorting, another thing I noticed was that some of these company names belong to the same company, but the individuals wrote them differently.\n\nAn example of this is `'IBM Global Solution Center'` and `'IBM'`; for our purposes, these should both be classified as `IBM`.\n\nLet's run through a fuzzy match run using [difflib's `get_close_matches`](https://docs.python.org/3/library/difflib.html#difflib.get_close_matches) to try and bucket some of these similar company names.\n```python\nfrom difflib import get_close_matches\n\ncompanies = df['Company'].drop_duplicates()\n\n# cutoff=0.7 is a similarity ranking, and n=10 just takes the top 10 values\nsimilar_companies = {x: get_close_matches(x, companies, n=10, cutoff=0.7)\n                     for x in companies}\n\n# We are only interested in the entries that had another match\nsimilar_companies = {x: [name for name in y if name != x]\n                     for x, y in similar_companies.items() if len(y) > 1}\n```\n\nNow, this solution is not perfect, but it will help draw out some similar companies. You should still run a manual inspection of the data (the IBM example I gave above is one that doesn't show up in the fuzzy match results).\n\nBased upon the results, let's group together some of the companies that had matches.\n```python\ndf['Company'] = df['Company'].replace({\n    'KPMG US': similar_companies['KPMG US'],\n    'Self-employed': similar_companies['Self-employed'],\n    'IBM Global Solution Center': 'IBM',\n})\n```\n\nThe next thing you may have noticed is that in our `similar_companies` dictionary, we cleaned up a `Self-employed` entry.\n\nTo stay aligned with our goal, let's drop these entries, as well as your current company.\n```python\ncompanies_to_drop = ['self employed', 'your current company']\ndf = df[~df['Company'].str.lower().isin(companies_to_drop)]\n```\n\n### Aggregating the data\nNow that our data is cleaned up a bit, let's aggregate and sum the number of connections for each of the companies.\n\n```python\ndf_company_counts = df['Company'].value_counts().reset_index()\ndf_company_counts.columns = ['Company', 'Count']  # For ease of understanding\ndf_company_counts = df_company_counts.sort_values(by='Count', ascending=False)\n```\n\n## Creating the network\n\nWe have the numbers we want for each company, now let's jump into using `NetworkX` to recreate a network.\n\nThe first step will be to initialize our graph, and add yourself as the central node, as it is your network.\n\n```python\nimport networkx as nx\n\nG = nx.Graph()\nG.add_node('Me')\n```\n\nThen, we'll loop through our `df_company_counts` DataFrame and add each company as a node.\n\n_You'll notice some HTML tags in the title below, this is just to make it more readable for later_\n```python\nfor _, row in df_company_counts.iterrows():\n\t# The title will be for more information later on\n    title = '<b>{0}</b> ({1})<br><hr>Positions:<br>'.format(row['Company'],\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\trow['Count'])\n\n    # In addition to the full company name, let's add each position in a\n    # list to see the roles our connections have at these companies\n    position_list = ''.join('<li>{}</li>'.format(x)\n    \t\t\t\t\t\tfor x in df[df['Company'] == row['Company']]['Position'])\n    title += '<ul>{0}</ul>'.format(position_list)\n\n    # For ease of viewing, limit company names to 15 letters\n    node_name = row['Company']\n    if len(node_name) > 15:\n        node_name = node_name[:15] + '...'\n\n    # Add the node and an edge connection ourself to the new node\n    G.add_node(node_name, weight=row['Count'], size=row['Count'] * 2, title=title)\n    G.add_edge('Me', node_name)\n```\n\nAnd just like that, we've created our network of connections.\n\n\n## Visualization\n\nOur network graph is created, so let's get into visualizing the network.\n\nThere are a few options for visualizing networks including `matplotlib.pyplot`, but I found that `pyvis` was the easiest to use for several reasons:\n- `pyvis` generates an HTML file\n- Customization is made very easy\n- The graph is interactive by default\n\nLet's look into generating this HTML file.\n```python\nfrom pyvis.network import Network\n\nnt = Network('100%', '100%', bgcolor='#222222', font_color='white')\nnt.from_nx(G)\nnt.repulsion()  # Spaces out the nodes\nnt.show('nx.html')\n```\n\nAnd it's that simple! We specify a width and height, optional styling attributes, and then we can generate the network graph visual straight from what we created with NetworkX.\n\nNow we can see [the network we generated](/network/first-nx-graph.html).\n\nYou can hover over each node to see the total number of connections that work at the respective company, and below is a list of the positions held by your connections.\n\nAs you can see, this is a bit hard to read into since there are a lot of nodes. Try and imagine reading this with +1,000 connections.\n\n## Improving the output\n\nThere are a few ways that our network could be narrowed down.\n\nBeing a _Software Developer_, the thought that first occurred to me was to try and dial in on tech-related companies through known positions titles.\n\nTo do this, I thought of a list of buzzwords/common job titles that I've seen across LinkedIn, and filtered down the initial DataFrame.\n\nThen, we go through the same process we did in previous sections of generating and displaying the graph.\n\n_Again, this is not perfect, but it's a good starting point._\n```python\n# Filter down from a list of popular tech positions\npositions = [\n    'developer', 'engineer', 'ai', 'analytics', 'software', 'cloud', 'cto',\n    'sde', 'sre', 'saas', 'product', 'engineering', 'scientist', 'data',\n]\ndf = df[df['Position'].str.contains('|'.join(positions), case=False)]\ndf_company_counts = df['Company'].value_counts().reset_index()\ndf_company_counts.columns = ['Company', 'Count']\ndf_company_counts = df_company_counts.sort_values(by='Count', ascending=False)\n\n# Re-initialize the graph and add the nodes/edges again\nG = nx.Graph()\nG.add_node('Me')\n\nfor _, row in df_company_counts.iterrows():\n    title = '<b>{0}</b> ({1})<br><hr>Positions:<br>'.format(row['Company'], row['Count'])\n    position_list = ''.join('<li>{}</li>'.format(x)\n    \t\t\t\t\t\tfor x in df[df['Company'] == row['Company']]['Position'])\n    title += '<ul>{0}</ul>'.format(position_list)\n    node_name = row['Company']\n    if len(node_name) > 15:\n        node_name = node_name[:15] + '...'\n\n    # Since there are less nodes, let's increase the sizes\n    G.add_node(node_name, weight=row['Count'], size=row['Count'] * 5, title=title)\n    G.add_edge('Me', node_name)\n\n# Generate the visualization\nnt = Network('100%', '100%', bgcolor='#222222', font_color='white')\nnt.from_nx(G)\nnt.repulsion()\nnt.show('nx.html')\n```\n\nNow, let's look at the [updated results](/network/second-nx-graph.html).\n\nMuch better! This is more readable and easier to interact with.\n\nAnd just like that, we achieved our goal of gaining a broader understanding of the companies in our LinkedIn network.\n\n---\n\n**_Possible improvements for those interested_**\n- Scraping the profile location of each of your connections to segment by location\n- Compiling a list of companies you'd like to work for/are interested in and creating a filtering system\n- Researching salary data for positions and gathering average pay by company\n\n---\n","title":"Visualizing your LinkedIn connections using Python","date":"2021-04-08","tags":["python","pandas"],"description":"Using Python's Pandas, NetworkX, and pyvis to understand and visualize companies within a directly connected LinkedIn network."}]},"__N_SSG":true}