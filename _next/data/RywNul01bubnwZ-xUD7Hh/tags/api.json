{"pageProps":{"tag":"api","taggedPosts":[{"id":"slack-webhook","contentHtml":"<h2>tl;dr</h2>\n<h3>Goal</h3>\n<p><em>To set up a Slack webhook so we can send text and simple HTML notifications to receive in a Slack channel.</em></p>\n<h3>Process Overview</h3>\n<ol>\n<li>Setting up a Slack webhook URL in your Slack workspace to post to a channel</li>\n<li>Posting a notification to our webhook</li>\n<li>Creating a simple HTML parser to match the custom Slack markdown flavor</li>\n</ol>\n<h3>Python Dependencies</h3>\n<pre><code># Python standard library\nfrom html.parser import HTMLParser\nimport logging\nimport os\nimport re\nfrom typing import Any, List, Tuple\n\n# 3rd Party\nimport requests\n</code></pre>\n<h3>Assumptions</h3>\n<p>I'll assume you have a Slack account, a Slack workspace setup, Slack is installed, and you have knowledge of Python with a basic understanding of webhooks.</p>\n<hr>\n<p>If you haven't heard of it before, <a href=\"https://slack.com/\">Slack</a> is a very popular team/workplace communication tool.  In addition to direct messaging, it allows you to separate discussion into various topics or <strong>channels</strong> for more focused team communication.</p>\n<p>Another great feature of Slack is that you can add 3rd party <a href=\"https://slack.com/apps\">apps</a> (or integrations) from your existing stack, or even develop your own!  I have seen this streamline my own productivity, and I personally use a number of Slack apps.</p>\n<p>To name a few, you may want to check out the following (assuming you use these tools) which I've found a lot of value in:</p>\n<ul>\n<li><a href=\"https://slack.com/apps/A011MFBJEUU-sentry?tab=more_info\">Sentry</a> - for application monitoring</li>\n<li><a href=\"https://slack.com/apps/ADZ494LHY-google-calendar?tab=more_info\">Google Calendar</a> - to stay on top of my meetings schedule</li>\n<li><a href=\"https://slack.com/apps/A01BP7R4KNY-github?tab=more_info\">GitHub</a> - getting notified of pull requests and meaningful changes to important repositories</li>\n<li><a href=\"https://slack.com/apps/A2RPP3NFR-jira-cloud?tab=more_info\">Jira Cloud</a> - staying on top of changes to Jira tickets</li>\n<li><a href=\"https://slack.com/apps/A6L22LZNH-aws-chatbot?tab=more_info\">AWS Chatbot</a> - alerts from CloudWatch alarms</li>\n</ul>\n<p>You can browse the <a href=\"https://slack.com/apps\">Slack app directory</a> for more integrations.</p>\n<p>However, not every integration is going to provide the functionality you need.  This post will focus on creating our own custom Slack app with the goal of posting simple notifications to a Slack channel.</p>\n<p>A common use case where we can apply our app will be sending notifications when any sort of user activity happens on a platform.  As a developer, being notified of when a user completes a certain task can provide a lot of transparency and understanding into the usage of our application, while also keeping a sales teams informed on relevant activity on the platform.  This is the use case we'll focus on.</p>\n<p>We will do this by posting to a webhook hosted by Slack.  For more information on webhooks, you can check out <a href=\"https://zapier.com/blog/what-are-webhooks/\">this article</a> by Zapier.</p>\n<p>Let's get started!</p>\n<hr>\n<h2>Setting up the Slack App</h2>\n<p>Open Slack, click <strong>Add channels</strong>, and create a new channel called <code>notifications</code>.  This is where our Slack app will post to once we set it up.</p>\n<p><img src=\"/images/slack-webhook/create-channel.jpg\" alt=\"Create a Slack channel {priority}{1004x580}\"></p>\n<p>Now go to a web browser and head to https://api.slack.com/apps/.</p>\n<p>Click on <strong>Create an App</strong></p>\n<p><img src=\"/images/slack-webhook/create-app.jpg\" alt=\"Create a Slack App {1004x497}\"></p>\n<p>Select <strong>From scratch</strong></p>\n<p><img src=\"/images/slack-webhook/from-scratch.jpg\" alt=\"Select From Scratch {1004x497}\"></p>\n<p>Create a name for your app and select the workspace you just created your <code>notifications</code> channel in.</p>\n<p><img src=\"/images/slack-webhook/app-and-workspace.jpg\" alt=\"Choose an app name and workspace {1004x501}\"></p>\n<p>This will redirect you to the <strong>Basic Information</strong> tab for your app.  Here, we'll enable <strong>Incoming Webhooks</strong>.  As it states, this will enable us to post messages from an external source.  In this case, our platform.</p>\n<p><img src=\"/images/slack-webhook/add-webhooks.jpg\" alt=\"Enable incoming webhooks {1004x497}\"></p>\n<p>Turn on <strong>Activate Incoming Webhooks</strong> and you will see additional details appear.  Towards the bottom, click on <strong>Add New Webhook to Workspace</strong>.</p>\n<p><img src=\"/images/slack-webhook/add-new-webhook.jpg\" alt=\"Add a new webhook to your workspace {1004x485}\"></p>\n<p>You will be redirected again to select which channel to post to.  Select the <code>notifications</code> channel that we previously created and press <strong>Allow</strong>.</p>\n<p><img src=\"/images/slack-webhook/choose-channel.jpg\" alt=\"Select a channel for your app {1004x498}\"></p>\n<p>This will redirect you back to your app configuration and you will see a webhook URL you can now post to.  This will also include a simple curl POST request you can test with if you'd like.  Copy the webhook URL for later, and remember to <strong>keep it private</strong>.  This is a public URL that anyone can post to.</p>\n<p><img src=\"/images/slack-webhook/copy-url.jpg\" alt=\"Copy your webhook URL {680x506}\"></p>\n<p>You can return to the <strong>Basic Information</strong> of your app settings in Slack to view more API credentials and also edit the look and feel of your new Slack bot.</p>\n<p>Now we're ready to dive into the code to communicate with our webhook!</p>\n<hr>\n<h2>Communicating with our Webhook</h2>\n<p>To communicate with our webhook, we'll use the <a href=\"https://docs.python-requests.org/en/master/\"><code>requests</code></a> Python library.  This is a third party library, so you'll want to have a Python virtual environment set up to handle your dependencies.  Virtual environments are out of the scope of this article, but you can read more on them <a href=\"https://docs.python.org/3/tutorial/venv.html\">here</a>.</p>\n<p>Inside your virtual environment, you can run the following to install the library.</p>\n<pre><code>pip install requests\n</code></pre>\n<p>Now, we'll set up a class to communicate with our Slack endpoint.  We'll start by just sending a plain text message to Slack.</p>\n<pre><code>import logging\n\nimport requests\n\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\nclass SlackWebhookBot:\n    def __init__(self, webhook_url: str, timeout: int = 15):\n        \"\"\"Class to send messages to a provided Slack webhook URL.\n\n        You can read more about Slack's Incoming Webhooks here:\n            https://api.slack.com/messaging/webhooks\n        \n        Args:\n            webhook_url: The webhook URL to send a message to.  Typically\n                formatted like \"https://hooks.slack.com/services/...\".\n        \n        Kwargs:\n            timeout: Number of seconds before the request will timeout.\n                This is used to prevent a hang and is set to a default\n                value of 15 seconds.\n        \"\"\"\n        self.webhook_url = webhook_url\n        self.timeout = timeout\n        self.headers = {\n            'Content-Type': 'application/json',\n        }\n    \n\n    def send(self, message: str) -> bool:\n        \"\"\"Sends a message to the webhook URL.\n\n        Per the Slack Incoming Webhook example.  The body of the request\n        (for plain text) should be formatted as follows:\n            `{\"text\": \"Hello, World!\"}`\n\n        Args:\n            message: Plain text string to send to Slack.\n\n        Returns:\n            A boolean representing if the request was successful.\n        \"\"\"\n        success = False\n        payload = {\n            'text': message,\n        }\n        try:\n            r = requests.post(\n                self.webhook_url,\n                headers=self.headers,\n                json=payload,\n                timeout=self.timeout\n            )\n        except requests.Timeout:\n            logger.error('Timeout occurred when trying to send message to Slack.')\n        except requests.RequestException as e:\n            logger.error(f'Error occurred when communicating with Slack: {e}.')\n        else:\n            success = True\n            logger.info('Successfully sent message to Slack.')\n\n        return success\n</code></pre>\n<p>Above is the basic setup for communicating with the Slack webhook.  We can run a quick test by moving this code to a script and adding the following.</p>\n<pre><code>import os\n\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nslack = SlackWebhookBot(webhook_url)\nslack.send('Hello, world!')\n</code></pre>\n<p>Make sure to set your Slack webhook URL to the <code>SLACK_WEBHOOK_URL</code> environment variable, and make sure you're in your virtual environment with the <code>requests</code> package installed before running the script.  This can be done on MacOS with the following.</p>\n<pre><code>export SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...\npython slack_webhook.py\n</code></pre>\n<p>When you run this, you should see a message from you Slack bot appear in the <code>notifications</code> channel!</p>\n<p><img src=\"/images/slack-webhook/slack-first-message.jpg\" alt=\"Hello world message in Slack {1004x675}\"></p>\n<p>For our notifications to be more helpful, we may want to add links or other formatting.  To do this, we will write our notifications with HTML tags, and then parse these tags and convert them to the <a href=\"https://api.slack.com/reference/surfaces/formatting\">Slack flavored Markdown</a> called <code>mrkdwn</code>.</p>\n<hr>\n<h2>Adding a simple HTML parser to our class</h2>\n<p>From the <a href=\"https://api.slack.com/reference/surfaces/formatting\">Slack formatting guide</a> for messages, we can see all of the ways to format text in our messages.  For our purposes, we will focus on a primary list.</p>\n<ul>\n<li>Making text <code>_italicized_</code> (<code>&#x3C;i></code>)</li>\n<li>Making text <code>*bold*</code> (<code>&#x3C;b></code>)</li>\n<li>Striking through ~<code>text</code>~ (<code>&#x3C;strike></code>)</li>\n<li>Adding line breaks (<code>&#x3C;br></code>)</li>\n<li>Adding <code>one-line code blocks</code> using the backtick character (<code>&#x3C;code></code>)</li>\n<li>Adding unordered lists (line broken dashes) (<code>&#x3C;ul>&#x3C;li></code>)</li>\n<li>Adding external links <code>&#x3C;[external link]|[display text]></code> (<code>&#x3C;a></code>)</li>\n</ul>\n<p>Also note that the Slack documentation says that <a href=\"https://api.slack.com/reference/surfaces/formatting#escaping\">certain characters need to be escaped</a>.</p>\n<p>There are a few more styles that could be implemented, but we'll focus on just this list for this post.</p>\n<p>To do this, we will utilize the <a href=\"https://docs.python.org/3/library/html.html\"><code>html</code></a> module in the Python standard library to parse HTML tags, attributes, and values.</p>\n<p>Let's write a class (we need to inherit functions for the <code>HTMLParser</code> class) where we will parse all of the tags and attributes, and escape the message text when needed.  The idea here is that we can construct a string from scratch and for each tag we care about we can \"replace\" the HTML tags with the relevant mrkdwn syntax.</p>\n<pre><code>from html.parser import HTMLParser\nimport re\nfrom typing import Any, List, Tuple\n\n\nclass SlackHTMLParser(HTMLParser):\n    def __init__(self, *args, **kwargs):\n        \"\"\"Escapes and converts an HTML string to Slack flavored\n        Markdown (mrkdwn).\n\n        More about Slack's Markdown Flavor (mrkdwn) can be seen here:\n            https://api.slack.com/reference/surfaces/formatting\n        \n        Call using `SlackHTMLParser(message_body).parse()`.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.slack_message = ''\n        self.ignore_tag = False  # Used to skip tags we don't care about\n        self.line_break = '::LINE::BREAK::'  # Unique sequence for swapping a &#x3C;br>\n\n\n    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Any]]):\n        \"\"\"Called when the opening of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n            attrs: List of tuples with the tuple having the following form:\n                (attribute name, value).  E.G. ('href', 'www.example.com').\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag in ['br', 'p', 'ul']:\n            self.slack_message += self.line_break\n        elif tag == 'li':\n            self.slack_message += f'{self.line_break}- '\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            href = [x[1] for x in attrs if x[0] == 'href']\n            if len(href) > 0:\n                self.slack_message += f'&#x3C;{href[0]}|'\n        else:\n            self.ignore_tag = True\n\n\n    def handle_data(self, data: str):\n        \"\"\"Handles the data within a tag.\n\n        This is called after `handle_starttag` and before `handle_endtag`.\n\n        We will also escape the following text per Slack's documentation:\n        - '&#x26;' -> '&#x26;amp;'\n        - '&#x3C;' -> '&#x26;lt;'\n        - '>' -> '&#x26;gt;'\n\n        Args:\n            data: The data/string within the HTML tag.\n        \"\"\"\n        if not self.ignore_tag:\n            self.slack_message += data\\\n                .replace('&#x26;', '&#x26;amp;')\\\n                .replace('&#x3C;', '&#x26;lt;')\\\n                .replace('>', '&#x26;gt;')\n\n\n    def handle_endtag(self, tag: str):\n        \"\"\"Called when the closing of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.  This is basically the same as the handle_starttag.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag == 'p':\n            self.slack_message += self.line_break\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            self.slack_message += '>'\n        \n        self.ignore_tag = False\n\n\n    def parse(self, html_string: str) -> str:\n        \"\"\"Parses a given HTML string and applies simple formatting.\n        \n        Note that we need to apply the line break replacing here\n        instead of with the handle tag methods.\n\n        Args:\n            html_string: The HTML string to convert to Slack mrkdwn.\n\n        Returns:\n            A formatted Slack mrkdwn string.\n        \"\"\"\n        self.feed(html_string)\n        return re.sub(\n            r'^(\\n)+',  # Remove the leading line breaks\n            '',\n            ' '.join(self.slack_message.split()).replace(self.line_break, '\\n')\n        )\n</code></pre>\n<p>We can test our class out with the following code.</p>\n<pre><code>html_string = '''\n    &#x3C;p>\n        Here &#x3C;i>is&#x3C;/i> a &#x3C;strike>paragraph&#x3C;/strike> with a &#x3C;b>lot&#x3C;/b> of formatting.\n    &#x3C;/p>\n    &#x3C;br>\n    &#x3C;code>Code sample&#x3C;/code> &#x26; testing escape.\n    &#x3C;ul>\n        &#x3C;li>\n            &#x3C;a href=\"https://www.google.com\">Google&#x3C;/a>\n        &#x3C;/li>\n        &#x3C;li>\n            &#x3C;a href=\"https://www.amazon.com\">Amazon&#x3C;/a>\n        &#x3C;/li>\n    &#x3C;/ul>\n'''\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nprint(slack_message)\n</code></pre>\n<p>Now we can test our formatter in an actual Slack message!  Import your formatter class or add it to your existing code so you're able to do the following.</p>\n<pre><code>html_string = '''\n    &#x3C;p>\n        Here &#x3C;i>is&#x3C;/i> a &#x3C;strike>paragraph&#x3C;/strike> with a &#x3C;b>lot&#x3C;/b> of formatting.\n    &#x3C;/p>\n    &#x3C;br>\n    &#x3C;code>Code sample&#x3C;/code> &#x26; testing escape.\n    &#x3C;ul>\n        &#x3C;li>\n            &#x3C;a href=\"https://www.google.com\">Google&#x3C;/a>\n        &#x3C;/li>\n        &#x3C;li>\n            &#x3C;a href=\"https://www.amazon.com\">Amazon&#x3C;/a>\n        &#x3C;/li>\n    &#x3C;/ul>\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message)\n</code></pre>\n<p>You should see the following message in your notifications channel.</p>\n<p><img src=\"/images/slack-webhook/slack-format-message.jpg\" alt=\"Second message in Slack {680x140}\"></p>\n<p>Looks pretty good!  <em>Note that you can still send plain text messages, you don't need to use HTML.</em></p>\n<p>For some final adjustments, you may have noticed that the message preview on the notification that popped up showed the actual <code>mrkdwn</code> characters as opposed to a formatted notification.  This looks a little sloppy, so let's make a new notification title that is similar to an email subject line.</p>\n<p>We will briefly look at the basics of Slack's <a href=\"https://api.slack.com/block-kit\">Block Kit</a>, which is a powerful way to add lots of customization to your Slack messages.  You can also explore Block Kit with Slack's <a href=\"https://app.slack.com/block-kit-builder/\">Block Kit Builder</a> which provides a preview of your Slack message.</p>\n<p>Without diving too much into the details on the Block Kit, let's update our <code>SlackWebhookBot</code> class and add a method that adds a title block and a body block for our message.  Our subject line will appear in the notification itself, and also in the actual Slack message.</p>\n<pre><code># Add the `Dict` typing import to the existing typing imports\nfrom typing import Dict\n\ndef format_message(self, subject: str, body: str) -> Dict:\n    \"\"\"Formats the subject and message body into Slack blocks.\n\n    Args:\n        subject: Subject that will appear on the notification popup.\n        body: The full message body.\n\n    Returns:\n        A dictionary payload with Slack block formatting.\n    \"\"\"\n    return {\n        'text': subject,\n        'blocks': [\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': f'*{subject}*',\n                },\n            },\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': body,\n                },\n            },\n        ],\n    }\n</code></pre>\n<p>Now we can tweak our <code>send</code> method to format a new message and accept a subject string as a Kwarg.</p>\n<pre><code>def send(self, message: str, subject: str = 'New message!') -> bool:\n    \"\"\"Sends a formatted message to the webhook URL.\n\n    Args:\n        message: Plain text string to send to Slack.\n\n    Kwargs:\n        subject: The subject of the message that will appear in the notification\n            preview.\n\n    Returns:\n        A boolean representing if the request was successful.\n    \"\"\"\n    success = False\n    payload = self.format_message(subject, message)\n    try:\n        r = requests.post(\n            self.webhook_url,\n            headers=self.headers,\n            json=payload,\n            timeout=self.timeout\n        )\n    except requests.Timeout:\n        logger.error('Timeout occurred when trying to send message to Slack.')\n    except requests.RequestException as e:\n        logger.error(f'Error occurred when communicating with Slack: {e}.')\n    else:\n        success = True\n        logger.info('Successfully sent message to Slack.')\n\n    return success\n</code></pre>\n<p>And we can test our notification with a new subject line.</p>\n<pre><code>html_string = '''\n    &#x3C;p>\n        Here &#x3C;i>is&#x3C;/i> a &#x3C;strike>paragraph&#x3C;/strike> with a &#x3C;b>lot&#x3C;/b> of formatting.\n    &#x3C;/p>\n    &#x3C;br>\n    &#x3C;code>Code sample&#x3C;/code> &#x26; testing escape.\n    &#x3C;ul>\n        &#x3C;li>\n            &#x3C;a href=\"https://www.google.com\">Google&#x3C;/a>\n        &#x3C;/li>\n        &#x3C;li>\n            &#x3C;a href=\"https://www.amazon.com\">Amazon&#x3C;/a>\n        &#x3C;/li>\n    &#x3C;/ul>\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message, subject='You\\'ve completed the tutorial!')\n</code></pre>\n<p>You should see a notification appear with the following preview</p>\n<p><img src=\"/images/slack-webhook/slack-popup.jpg\" alt=\"Slack notification {453x101}\"></p>\n<p>and the following message in your channel.</p>\n<p><img src=\"/images/slack-webhook/slack-last-message.jpg\" alt=\"Last message in Slack {680x159}\"></p>\n<p>We have a custom Slack notification app!  You can place the <code>send</code> message calls all across your applications with related messages and now you can have a better pulse on user activity that developers and any other employees/stakeholders can easily access.</p>\n<hr>\n<p>For those wanting additional challenges or to continue developing their custom app, Slack has added a lot of really cool tools to the Block Kit.  There are a ton of really cool possibilities that can be added on by updating the <code>format_message</code> method in our <code>SlackWebhookBot</code> class.</p>\n<p>Explore the Slack's <a href=\"https://app.slack.com/block-kit-builder/\">Block Kit Builder</a> and see what you can make!</p>\n<hr>\n","markdown":"\n## tl;dr\n\n### Goal\n_To set up a Slack webhook so we can send text and simple HTML notifications to receive in a Slack channel._\n\n### Process Overview\n1. Setting up a Slack webhook URL in your Slack workspace to post to a channel\n2. Posting a notification to our webhook\n3. Creating a simple HTML parser to match the custom Slack markdown flavor\n\n### Python Dependencies\n```python\n# Python standard library\nfrom html.parser import HTMLParser\nimport logging\nimport os\nimport re\nfrom typing import Any, List, Tuple\n\n# 3rd Party\nimport requests\n```\n\n### Assumptions\nI'll assume you have a Slack account, a Slack workspace setup, Slack is installed, and you have knowledge of Python with a basic understanding of webhooks.\n\n---\n\nIf you haven't heard of it before, [Slack](https://slack.com/) is a very popular team/workplace communication tool.  In addition to direct messaging, it allows you to separate discussion into various topics or **channels** for more focused team communication.\n\nAnother great feature of Slack is that you can add 3rd party [apps](https://slack.com/apps) (or integrations) from your existing stack, or even develop your own!  I have seen this streamline my own productivity, and I personally use a number of Slack apps.\n\nTo name a few, you may want to check out the following (assuming you use these tools) which I've found a lot of value in:\n- [Sentry](https://slack.com/apps/A011MFBJEUU-sentry?tab=more_info) - for application monitoring\n- [Google Calendar](https://slack.com/apps/ADZ494LHY-google-calendar?tab=more_info) - to stay on top of my meetings schedule\n- [GitHub](https://slack.com/apps/A01BP7R4KNY-github?tab=more_info) - getting notified of pull requests and meaningful changes to important repositories\n- [Jira Cloud](https://slack.com/apps/A2RPP3NFR-jira-cloud?tab=more_info) - staying on top of changes to Jira tickets\n- [AWS Chatbot](https://slack.com/apps/A6L22LZNH-aws-chatbot?tab=more_info) - alerts from CloudWatch alarms\n\nYou can browse the [Slack app directory](https://slack.com/apps) for more integrations.\n\nHowever, not every integration is going to provide the functionality you need.  This post will focus on creating our own custom Slack app with the goal of posting simple notifications to a Slack channel.\n\nA common use case where we can apply our app will be sending notifications when any sort of user activity happens on a platform.  As a developer, being notified of when a user completes a certain task can provide a lot of transparency and understanding into the usage of our application, while also keeping a sales teams informed on relevant activity on the platform.  This is the use case we'll focus on.\n\nWe will do this by posting to a webhook hosted by Slack.  For more information on webhooks, you can check out [this article](https://zapier.com/blog/what-are-webhooks/) by Zapier.\n\nLet's get started!\n\n---\n\n## Setting up the Slack App\nOpen Slack, click **Add channels**, and create a new channel called `notifications`.  This is where our Slack app will post to once we set it up.\n\n![Create a Slack channel {priority}{1004x580}](/images/slack-webhook/create-channel.jpg)\n\nNow go to a web browser and head to https://api.slack.com/apps/.\n\nClick on **Create an App**\n\n![Create a Slack App {1004x497}](/images/slack-webhook/create-app.jpg)\n\nSelect **From scratch**\n\n![Select From Scratch {1004x497}](/images/slack-webhook/from-scratch.jpg)\n\nCreate a name for your app and select the workspace you just created your `notifications` channel in.\n\n![Choose an app name and workspace {1004x501}](/images/slack-webhook/app-and-workspace.jpg)\n\n\nThis will redirect you to the **Basic Information** tab for your app.  Here, we'll enable **Incoming Webhooks**.  As it states, this will enable us to post messages from an external source.  In this case, our platform.\n\n![Enable incoming webhooks {1004x497}](/images/slack-webhook/add-webhooks.jpg)\n\n\nTurn on **Activate Incoming Webhooks** and you will see additional details appear.  Towards the bottom, click on **Add New Webhook to Workspace**.\n\n![Add a new webhook to your workspace {1004x485}](/images/slack-webhook/add-new-webhook.jpg)\n\nYou will be redirected again to select which channel to post to.  Select the `notifications` channel that we previously created and press **Allow**.\n\n![Select a channel for your app {1004x498}](/images/slack-webhook/choose-channel.jpg)\n\n\nThis will redirect you back to your app configuration and you will see a webhook URL you can now post to.  This will also include a simple curl POST request you can test with if you'd like.  Copy the webhook URL for later, and remember to **keep it private**.  This is a public URL that anyone can post to.\n\n![Copy your webhook URL {680x506}](/images/slack-webhook/copy-url.jpg)\n\n\nYou can return to the **Basic Information** of your app settings in Slack to view more API credentials and also edit the look and feel of your new Slack bot.\n\nNow we're ready to dive into the code to communicate with our webhook!\n\n---\n\n## Communicating with our Webhook\nTo communicate with our webhook, we'll use the [`requests`](https://docs.python-requests.org/en/master/) Python library.  This is a third party library, so you'll want to have a Python virtual environment set up to handle your dependencies.  Virtual environments are out of the scope of this article, but you can read more on them [here](https://docs.python.org/3/tutorial/venv.html).\n\nInside your virtual environment, you can run the following to install the library.\n```bash\npip install requests\n```\n\nNow, we'll set up a class to communicate with our Slack endpoint.  We'll start by just sending a plain text message to Slack.\n\n```python\nimport logging\n\nimport requests\n\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\nclass SlackWebhookBot:\n    def __init__(self, webhook_url: str, timeout: int = 15):\n        \"\"\"Class to send messages to a provided Slack webhook URL.\n\n        You can read more about Slack's Incoming Webhooks here:\n            https://api.slack.com/messaging/webhooks\n        \n        Args:\n            webhook_url: The webhook URL to send a message to.  Typically\n                formatted like \"https://hooks.slack.com/services/...\".\n        \n        Kwargs:\n            timeout: Number of seconds before the request will timeout.\n                This is used to prevent a hang and is set to a default\n                value of 15 seconds.\n        \"\"\"\n        self.webhook_url = webhook_url\n        self.timeout = timeout\n        self.headers = {\n            'Content-Type': 'application/json',\n        }\n    \n\n    def send(self, message: str) -> bool:\n        \"\"\"Sends a message to the webhook URL.\n\n        Per the Slack Incoming Webhook example.  The body of the request\n        (for plain text) should be formatted as follows:\n            `{\"text\": \"Hello, World!\"}`\n\n        Args:\n            message: Plain text string to send to Slack.\n\n        Returns:\n            A boolean representing if the request was successful.\n        \"\"\"\n        success = False\n        payload = {\n            'text': message,\n        }\n        try:\n            r = requests.post(\n                self.webhook_url,\n                headers=self.headers,\n                json=payload,\n                timeout=self.timeout\n            )\n        except requests.Timeout:\n            logger.error('Timeout occurred when trying to send message to Slack.')\n        except requests.RequestException as e:\n            logger.error(f'Error occurred when communicating with Slack: {e}.')\n        else:\n            success = True\n            logger.info('Successfully sent message to Slack.')\n\n        return success\n```\n\nAbove is the basic setup for communicating with the Slack webhook.  We can run a quick test by moving this code to a script and adding the following.\n```python\nimport os\n\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nslack = SlackWebhookBot(webhook_url)\nslack.send('Hello, world!')\n```\n\nMake sure to set your Slack webhook URL to the `SLACK_WEBHOOK_URL` environment variable, and make sure you're in your virtual environment with the `requests` package installed before running the script.  This can be done on MacOS with the following.\n```bash\nexport SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...\npython slack_webhook.py\n```\n\nWhen you run this, you should see a message from you Slack bot appear in the `notifications` channel!\n\n![Hello world message in Slack {1004x675}](/images/slack-webhook/slack-first-message.jpg)\n\n\nFor our notifications to be more helpful, we may want to add links or other formatting.  To do this, we will write our notifications with HTML tags, and then parse these tags and convert them to the [Slack flavored Markdown](https://api.slack.com/reference/surfaces/formatting) called `mrkdwn`.\n\n---\n\n## Adding a simple HTML parser to our class\nFrom the [Slack formatting guide](https://api.slack.com/reference/surfaces/formatting) for messages, we can see all of the ways to format text in our messages.  For our purposes, we will focus on a primary list.\n\n- Making text <i>`_italicized_`</i> (`<i>`)\n- Making text <b>`*bold*`</b> (`<b>`)\n- Striking through ~<strike>`text`</strike>~ (`<strike>`)\n- Adding line breaks (`<br>`)\n- Adding `one-line code blocks` using the backtick character (`<code>`)\n- Adding unordered lists (line broken dashes) (`<ul><li>`)\n- Adding external links `<[external link]|[display text]>` (`<a>`)\n\nAlso note that the Slack documentation says that [certain characters need to be escaped](https://api.slack.com/reference/surfaces/formatting#escaping).\n\nThere are a few more styles that could be implemented, but we'll focus on just this list for this post.\n\nTo do this, we will utilize the [`html`](https://docs.python.org/3/library/html.html) module in the Python standard library to parse HTML tags, attributes, and values.\n\nLet's write a class (we need to inherit functions for the `HTMLParser` class) where we will parse all of the tags and attributes, and escape the message text when needed.  The idea here is that we can construct a string from scratch and for each tag we care about we can \"replace\" the HTML tags with the relevant mrkdwn syntax.\n\n```python\nfrom html.parser import HTMLParser\nimport re\nfrom typing import Any, List, Tuple\n\n\nclass SlackHTMLParser(HTMLParser):\n    def __init__(self, *args, **kwargs):\n        \"\"\"Escapes and converts an HTML string to Slack flavored\n        Markdown (mrkdwn).\n\n        More about Slack's Markdown Flavor (mrkdwn) can be seen here:\n            https://api.slack.com/reference/surfaces/formatting\n        \n        Call using `SlackHTMLParser(message_body).parse()`.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.slack_message = ''\n        self.ignore_tag = False  # Used to skip tags we don't care about\n        self.line_break = '::LINE::BREAK::'  # Unique sequence for swapping a <br>\n\n\n    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Any]]):\n        \"\"\"Called when the opening of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n            attrs: List of tuples with the tuple having the following form:\n                (attribute name, value).  E.G. ('href', 'www.example.com').\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag in ['br', 'p', 'ul']:\n            self.slack_message += self.line_break\n        elif tag == 'li':\n            self.slack_message += f'{self.line_break}- '\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            href = [x[1] for x in attrs if x[0] == 'href']\n            if len(href) > 0:\n                self.slack_message += f'<{href[0]}|'\n        else:\n            self.ignore_tag = True\n\n\n    def handle_data(self, data: str):\n        \"\"\"Handles the data within a tag.\n\n        This is called after `handle_starttag` and before `handle_endtag`.\n\n        We will also escape the following text per Slack's documentation:\n        - '&' -> '&amp;'\n        - '<' -> '&lt;'\n        - '>' -> '&gt;'\n\n        Args:\n            data: The data/string within the HTML tag.\n        \"\"\"\n        if not self.ignore_tag:\n            self.slack_message += data\\\n                .replace('&', '&amp;')\\\n                .replace('<', '&lt;')\\\n                .replace('>', '&gt;')\n\n\n    def handle_endtag(self, tag: str):\n        \"\"\"Called when the closing of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.  This is basically the same as the handle_starttag.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag == 'p':\n            self.slack_message += self.line_break\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            self.slack_message += '>'\n        \n        self.ignore_tag = False\n\n\n    def parse(self, html_string: str) -> str:\n        \"\"\"Parses a given HTML string and applies simple formatting.\n        \n        Note that we need to apply the line break replacing here\n        instead of with the handle tag methods.\n\n        Args:\n            html_string: The HTML string to convert to Slack mrkdwn.\n\n        Returns:\n            A formatted Slack mrkdwn string.\n        \"\"\"\n        self.feed(html_string)\n        return re.sub(\n            r'^(\\n)+',  # Remove the leading line breaks\n            '',\n            ' '.join(self.slack_message.split()).replace(self.line_break, '\\n')\n        )\n```\n\nWe can test our class out with the following code.\n\n```python\nhtml_string = '''\n    <p>\n        Here <i>is</i> a <strike>paragraph</strike> with a <b>lot</b> of formatting.\n    </p>\n    <br>\n    <code>Code sample</code> & testing escape.\n    <ul>\n        <li>\n            <a href=\"https://www.google.com\">Google</a>\n        </li>\n        <li>\n            <a href=\"https://www.amazon.com\">Amazon</a>\n        </li>\n    </ul>\n'''\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nprint(slack_message)\n```\n\nNow we can test our formatter in an actual Slack message!  Import your formatter class or add it to your existing code so you're able to do the following.\n\n```python\nhtml_string = '''\n    <p>\n        Here <i>is</i> a <strike>paragraph</strike> with a <b>lot</b> of formatting.\n    </p>\n    <br>\n    <code>Code sample</code> & testing escape.\n    <ul>\n        <li>\n            <a href=\"https://www.google.com\">Google</a>\n        </li>\n        <li>\n            <a href=\"https://www.amazon.com\">Amazon</a>\n        </li>\n    </ul>\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message)\n```\n\nYou should see the following message in your notifications channel.\n\n![Second message in Slack {680x140}](/images/slack-webhook/slack-format-message.jpg)\n\nLooks pretty good!  _Note that you can still send plain text messages, you don't need to use HTML._\n\nFor some final adjustments, you may have noticed that the message preview on the notification that popped up showed the actual `mrkdwn` characters as opposed to a formatted notification.  This looks a little sloppy, so let's make a new notification title that is similar to an email subject line.\n\nWe will briefly look at the basics of Slack's [Block Kit](https://api.slack.com/block-kit), which is a powerful way to add lots of customization to your Slack messages.  You can also explore Block Kit with Slack's [Block Kit Builder](https://app.slack.com/block-kit-builder/) which provides a preview of your Slack message.\n\nWithout diving too much into the details on the Block Kit, let's update our `SlackWebhookBot` class and add a method that adds a title block and a body block for our message.  Our subject line will appear in the notification itself, and also in the actual Slack message.\n\n```python\n# Add the `Dict` typing import to the existing typing imports\nfrom typing import Dict\n\ndef format_message(self, subject: str, body: str) -> Dict:\n    \"\"\"Formats the subject and message body into Slack blocks.\n\n    Args:\n        subject: Subject that will appear on the notification popup.\n        body: The full message body.\n\n    Returns:\n        A dictionary payload with Slack block formatting.\n    \"\"\"\n    return {\n        'text': subject,\n        'blocks': [\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': f'*{subject}*',\n                },\n            },\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': body,\n                },\n            },\n        ],\n    }\n```\n\nNow we can tweak our `send` method to format a new message and accept a subject string as a Kwarg.\n\n```python\ndef send(self, message: str, subject: str = 'New message!') -> bool:\n    \"\"\"Sends a formatted message to the webhook URL.\n\n    Args:\n        message: Plain text string to send to Slack.\n\n    Kwargs:\n        subject: The subject of the message that will appear in the notification\n            preview.\n\n    Returns:\n        A boolean representing if the request was successful.\n    \"\"\"\n    success = False\n    payload = self.format_message(subject, message)\n    try:\n        r = requests.post(\n            self.webhook_url,\n            headers=self.headers,\n            json=payload,\n            timeout=self.timeout\n        )\n    except requests.Timeout:\n        logger.error('Timeout occurred when trying to send message to Slack.')\n    except requests.RequestException as e:\n        logger.error(f'Error occurred when communicating with Slack: {e}.')\n    else:\n        success = True\n        logger.info('Successfully sent message to Slack.')\n\n    return success\n```\n\nAnd we can test our notification with a new subject line.\n\n```python\nhtml_string = '''\n    <p>\n        Here <i>is</i> a <strike>paragraph</strike> with a <b>lot</b> of formatting.\n    </p>\n    <br>\n    <code>Code sample</code> & testing escape.\n    <ul>\n        <li>\n            <a href=\"https://www.google.com\">Google</a>\n        </li>\n        <li>\n            <a href=\"https://www.amazon.com\">Amazon</a>\n        </li>\n    </ul>\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message, subject='You\\'ve completed the tutorial!')\n```\n\nYou should see a notification appear with the following preview\n\n![Slack notification {453x101}](/images/slack-webhook/slack-popup.jpg)\n\n\nand the following message in your channel.\n\n![Last message in Slack {680x159}](/images/slack-webhook/slack-last-message.jpg)\n\n\nWe have a custom Slack notification app!  You can place the `send` message calls all across your applications with related messages and now you can have a better pulse on user activity that developers and any other employees/stakeholders can easily access.\n\n---\n\nFor those wanting additional challenges or to continue developing their custom app, Slack has added a lot of really cool tools to the Block Kit.  There are a ton of really cool possibilities that can be added on by updating the `format_message` method in our `SlackWebhookBot` class.\n\nExplore the Slack's [Block Kit Builder](https://app.slack.com/block-kit-builder/) and see what you can make!\n\n---\n","title":"Setting up a Slack webhook for simple notifications","date":"2021-07-11","tags":["python","webhook","api"],"description":"Setting up a Slack webhook to send plain text or simple HTML notifications to a Slack channel."}]},"__N_SSG":true}