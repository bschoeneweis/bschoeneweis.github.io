<!DOCTYPE html><html><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-193041393-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-193041393-1', {
              page_path: window.location.pathname,
            });
          </script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"/><link rel="preload" href="/fonts/FiraCode-VariableFont_wght.ttf" as="font" crossorigin="anonymous"/><link rel="icon" href="data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 100 100&#x27;&gt;&lt;text y=&#x27;.9em&#x27; font-size=&#x27;90&#x27;&gt;üëã&lt;/text&gt;&lt;/svg&gt;"/><meta name="description" content="Bradley Schoeneweis"/><meta property="og:image" content="https://og-image.vercel.app/Bradley%20Schoeneweis.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="robots" content="follow, index"/><meta name="og:title" content="Bradley Schoeneweis"/><meta property="og:site_name" content="Bradley Schoeneweis"/><meta property="og:description" content="Bradley Schoeneweis"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@bschoeneweis"/><meta name="twitter:title" content="Bradley Schoeneweis"/><meta name="twitter:description" content="Bradley Schoeneweis"/><meta name="twitter:image" content="https://og-image.vercel.app/Bradley%20Schoeneweis.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Posts tagged &quot;api&quot;</title><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/ce6eedf489eb1b9b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ce6eedf489eb1b9b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/dc9f83a6c4d0b6dc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dc9f83a6c4d0b6dc.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-09b9d5e6fafbbf92.js" defer=""></script><script src="/_next/static/chunks/framework-7d488969745094b0.js" defer=""></script><script src="/_next/static/chunks/main-c3ed9a593ffd1a6c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-059eeeec4cf736c4.js" defer=""></script><script src="/_next/static/chunks/4824-86805e89d9bc00a3.js" defer=""></script><script src="/_next/static/chunks/pages/tags/%5Btag%5D-8afd6df790ebe176.js" defer=""></script><script src="/_next/static/Od_YqLWoiun7axqz_XJ1D/_buildManifest.js" defer=""></script><script src="/_next/static/Od_YqLWoiun7axqz_XJ1D/_ssgManifest.js" defer=""></script><script src="/_next/static/Od_YqLWoiun7axqz_XJ1D/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_ArticleContainer__QR4qB"><header><div class="layout_LayoutLinks__92rCe"><a href="/">‚Üê Back home</a><a href="/tags">View All Tags</a></div></header><main><header><div class="utils_marginTop2_25__bRt80 utils_marginBottom1_25__XjeT0"><span class="tag_Badge__e6qwu tag_BadgeLarge__O0ytt">api</span></div></header><section class="utils_headingMd__gD1Ok utils_padding1rem__xPN3e utils_marginLeft0_5rem__qnumX "><ul class="utils_list__4Mu4l"><li class="utils_listItem__s2m6i"><a href="/posts/slack-webhook">Setting up a Slack webhook for simple notifications</a><br/><div class="utils_marginBottom0_5rem__dsxrK utils_marginTop0_5rem__E7OQF"><div class="tag_TagList__IWJKV"><div class="utils_displayFlex__VCtvW"><a href="/tags/python"><div><span class="tag_Badge__e6qwu utils_cursorPointer__oXutf">python</span></div></a></div><div class="utils_displayFlex__VCtvW"><a href="/tags/slack"><div class="tag_TagListItem__3M0uo"><span class="tag_Badge__e6qwu utils_cursorPointer__oXutf">slack</span></div></a></div><div class="utils_displayFlex__VCtvW"><a href="/tags/webhook"><div class="tag_TagListItem__3M0uo"><span class="tag_Badge__e6qwu utils_cursorPointer__oXutf">webhook</span></div></a></div><div class="utils_displayFlex__VCtvW"><a href="/tags/api"><div class="tag_TagListItem__3M0uo"><span class="tag_Badge__e6qwu utils_cursorPointer__oXutf">api</span></div></a></div></div></div><small class="utils_lightText__eUzGY"><time dateTime="2021-07-11">July 11, 2021</time></small></li></ul></section></main></div><footer class="footer_FooterContainer__oKXDJ"><div class="footer_Footer__wsKMY"><div class="footer_FooterName__4egKC">¬© <time>2022</time> Bradley Schoeneweis</div><div class="footer_FooterLinks__2mme5"><a href="https://www.linkedin.com/in/bradley-schoeneweis/" target="_blank"><img width="16" src="/icons/linkedin.svg" alt="linkedin logo" class="footer_SocialLinkLogo__OWB_i"/></a><a href="https://github.com/bschoeneweis" target="_blank"><img width="16" src="/icons/github.svg" alt="github logo" class="footer_SocialLinkLogo__OWB_i"/></a><a href="https://medium.com/@bradley-schoeneweis" target="_blank"><img width="16" src="/icons/medium.svg" alt="medium logo" class="footer_SocialLinkLogo__OWB_i"/></a><a href="https://dev.to/bschoeneweis" target="_blank"><img width="16" src="/icons/dev.svg" alt="dev logo" class="footer_SocialLinkLogo__OWB_i"/></a><a href="/feed.xml"><img width="16" src="/icons/rss.svg" alt="rss logo" class="footer_SocialLinkLogo__OWB_i"/></a></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"api","taggedPosts":[{"id":"slack-webhook","contentHtml":"\u003ch2\u003etl;dr\u003c/h2\u003e\n\u003ch3\u003eGoal\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eTo set up a Slack webhook so we can send text and simple HTML notifications to receive in a Slack channel.\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eProcess Overview\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eSetting up a Slack webhook URL in your Slack workspace to post to a channel\u003c/li\u003e\n\u003cli\u003ePosting a notification to our webhook\u003c/li\u003e\n\u003cli\u003eCreating a simple HTML parser to match the custom Slack markdown flavor\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003ePython Dependencies\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e# Python standard library\nfrom html.parser import HTMLParser\nimport logging\nimport os\nimport re\nfrom typing import Any, List, Tuple\n\n# 3rd Party\nimport requests\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eAssumptions\u003c/h3\u003e\n\u003cp\u003eI'll assume you have a Slack account, a Slack workspace setup, Slack is installed, and you have knowledge of Python with a basic understanding of webhooks.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eIf you haven't heard of it before, \u003ca href=\"https://slack.com/\"\u003eSlack\u003c/a\u003e is a very popular team/workplace communication tool.  In addition to direct messaging, it allows you to separate discussion into various topics or \u003cstrong\u003echannels\u003c/strong\u003e for more focused team communication.\u003c/p\u003e\n\u003cp\u003eAnother great feature of Slack is that you can add 3rd party \u003ca href=\"https://slack.com/apps\"\u003eapps\u003c/a\u003e (or integrations) from your existing stack, or even develop your own!  I have seen this streamline my own productivity, and I personally use a number of Slack apps.\u003c/p\u003e\n\u003cp\u003eTo name a few, you may want to check out the following (assuming you use these tools) which I've found a lot of value in:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://slack.com/apps/A011MFBJEUU-sentry?tab=more_info\"\u003eSentry\u003c/a\u003e - for application monitoring\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://slack.com/apps/ADZ494LHY-google-calendar?tab=more_info\"\u003eGoogle Calendar\u003c/a\u003e - to stay on top of my meetings schedule\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://slack.com/apps/A01BP7R4KNY-github?tab=more_info\"\u003eGitHub\u003c/a\u003e - getting notified of pull requests and meaningful changes to important repositories\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://slack.com/apps/A2RPP3NFR-jira-cloud?tab=more_info\"\u003eJira Cloud\u003c/a\u003e - staying on top of changes to Jira tickets\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://slack.com/apps/A6L22LZNH-aws-chatbot?tab=more_info\"\u003eAWS Chatbot\u003c/a\u003e - alerts from CloudWatch alarms\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can browse the \u003ca href=\"https://slack.com/apps\"\u003eSlack app directory\u003c/a\u003e for more integrations.\u003c/p\u003e\n\u003cp\u003eHowever, not every integration is going to provide the functionality you need.  This post will focus on creating our own custom Slack app with the goal of posting simple notifications to a Slack channel.\u003c/p\u003e\n\u003cp\u003eA common use case where we can apply our app will be sending notifications when any sort of user activity happens on a platform.  As a developer, being notified of when a user completes a certain task can provide a lot of transparency and understanding into the usage of our application, while also keeping a sales teams informed on relevant activity on the platform.  This is the use case we'll focus on.\u003c/p\u003e\n\u003cp\u003eWe will do this by posting to a webhook hosted by Slack.  For more information on webhooks, you can check out \u003ca href=\"https://zapier.com/blog/what-are-webhooks/\"\u003ethis article\u003c/a\u003e by Zapier.\u003c/p\u003e\n\u003cp\u003eLet's get started!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eSetting up the Slack App\u003c/h2\u003e\n\u003cp\u003eOpen Slack, click \u003cstrong\u003eAdd channels\u003c/strong\u003e, and create a new channel called \u003ccode\u003enotifications\u003c/code\u003e.  This is where our Slack app will post to once we set it up.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/create-channel.jpg\" alt=\"Create a Slack channel {priority}{1004x580}\"\u003e\u003c/p\u003e\n\u003cp\u003eNow go to a web browser and head to https://api.slack.com/apps/.\u003c/p\u003e\n\u003cp\u003eClick on \u003cstrong\u003eCreate an App\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/create-app.jpg\" alt=\"Create a Slack App {1004x497}\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect \u003cstrong\u003eFrom scratch\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/from-scratch.jpg\" alt=\"Select From Scratch {1004x497}\"\u003e\u003c/p\u003e\n\u003cp\u003eCreate a name for your app and select the workspace you just created your \u003ccode\u003enotifications\u003c/code\u003e channel in.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/app-and-workspace.jpg\" alt=\"Choose an app name and workspace {1004x501}\"\u003e\u003c/p\u003e\n\u003cp\u003eThis will redirect you to the \u003cstrong\u003eBasic Information\u003c/strong\u003e tab for your app.  Here, we'll enable \u003cstrong\u003eIncoming Webhooks\u003c/strong\u003e.  As it states, this will enable us to post messages from an external source.  In this case, our platform.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/add-webhooks.jpg\" alt=\"Enable incoming webhooks {1004x497}\"\u003e\u003c/p\u003e\n\u003cp\u003eTurn on \u003cstrong\u003eActivate Incoming Webhooks\u003c/strong\u003e and you will see additional details appear.  Towards the bottom, click on \u003cstrong\u003eAdd New Webhook to Workspace\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/add-new-webhook.jpg\" alt=\"Add a new webhook to your workspace {1004x485}\"\u003e\u003c/p\u003e\n\u003cp\u003eYou will be redirected again to select which channel to post to.  Select the \u003ccode\u003enotifications\u003c/code\u003e channel that we previously created and press \u003cstrong\u003eAllow\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/choose-channel.jpg\" alt=\"Select a channel for your app {1004x498}\"\u003e\u003c/p\u003e\n\u003cp\u003eThis will redirect you back to your app configuration and you will see a webhook URL you can now post to.  This will also include a simple curl POST request you can test with if you'd like.  Copy the webhook URL for later, and remember to \u003cstrong\u003ekeep it private\u003c/strong\u003e.  This is a public URL that anyone can post to.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/copy-url.jpg\" alt=\"Copy your webhook URL {680x506}\"\u003e\u003c/p\u003e\n\u003cp\u003eYou can return to the \u003cstrong\u003eBasic Information\u003c/strong\u003e of your app settings in Slack to view more API credentials and also edit the look and feel of your new Slack bot.\u003c/p\u003e\n\u003cp\u003eNow we're ready to dive into the code to communicate with our webhook!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eCommunicating with our Webhook\u003c/h2\u003e\n\u003cp\u003eTo communicate with our webhook, we'll use the \u003ca href=\"https://docs.python-requests.org/en/master/\"\u003e\u003ccode\u003erequests\u003c/code\u003e\u003c/a\u003e Python library.  This is a third party library, so you'll want to have a Python virtual environment set up to handle your dependencies.  Virtual environments are out of the scope of this article, but you can read more on them \u003ca href=\"https://docs.python.org/3/tutorial/venv.html\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eInside your virtual environment, you can run the following to install the library.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epip install requests\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we'll set up a class to communicate with our Slack endpoint.  We'll start by just sending a plain text message to Slack.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport logging\n\nimport requests\n\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\nclass SlackWebhookBot:\n    def __init__(self, webhook_url: str, timeout: int = 15):\n        \"\"\"Class to send messages to a provided Slack webhook URL.\n\n        You can read more about Slack's Incoming Webhooks here:\n            https://api.slack.com/messaging/webhooks\n        \n        Args:\n            webhook_url: The webhook URL to send a message to.  Typically\n                formatted like \"https://hooks.slack.com/services/...\".\n        \n        Kwargs:\n            timeout: Number of seconds before the request will timeout.\n                This is used to prevent a hang and is set to a default\n                value of 15 seconds.\n        \"\"\"\n        self.webhook_url = webhook_url\n        self.timeout = timeout\n        self.headers = {\n            'Content-Type': 'application/json',\n        }\n    \n\n    def send(self, message: str) -\u003e bool:\n        \"\"\"Sends a message to the webhook URL.\n\n        Per the Slack Incoming Webhook example.  The body of the request\n        (for plain text) should be formatted as follows:\n            `{\"text\": \"Hello, World!\"}`\n\n        Args:\n            message: Plain text string to send to Slack.\n\n        Returns:\n            A boolean representing if the request was successful.\n        \"\"\"\n        success = False\n        payload = {\n            'text': message,\n        }\n        try:\n            r = requests.post(\n                self.webhook_url,\n                headers=self.headers,\n                json=payload,\n                timeout=self.timeout\n            )\n        except requests.Timeout:\n            logger.error('Timeout occurred when trying to send message to Slack.')\n        except requests.RequestException as e:\n            logger.error(f'Error occurred when communicating with Slack: {e}.')\n        else:\n            success = True\n            logger.info('Successfully sent message to Slack.')\n\n        return success\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAbove is the basic setup for communicating with the Slack webhook.  We can run a quick test by moving this code to a script and adding the following.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport os\n\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nslack = SlackWebhookBot(webhook_url)\nslack.send('Hello, world!')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMake sure to set your Slack webhook URL to the \u003ccode\u003eSLACK_WEBHOOK_URL\u003c/code\u003e environment variable, and make sure you're in your virtual environment with the \u003ccode\u003erequests\u003c/code\u003e package installed before running the script.  This can be done on MacOS with the following.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...\npython slack_webhook.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen you run this, you should see a message from you Slack bot appear in the \u003ccode\u003enotifications\u003c/code\u003e channel!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/slack-first-message.jpg\" alt=\"Hello world message in Slack {1004x675}\"\u003e\u003c/p\u003e\n\u003cp\u003eFor our notifications to be more helpful, we may want to add links or other formatting.  To do this, we will write our notifications with HTML tags, and then parse these tags and convert them to the \u003ca href=\"https://api.slack.com/reference/surfaces/formatting\"\u003eSlack flavored Markdown\u003c/a\u003e called \u003ccode\u003emrkdwn\u003c/code\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eAdding a simple HTML parser to our class\u003c/h2\u003e\n\u003cp\u003eFrom the \u003ca href=\"https://api.slack.com/reference/surfaces/formatting\"\u003eSlack formatting guide\u003c/a\u003e for messages, we can see all of the ways to format text in our messages.  For our purposes, we will focus on a primary list.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMaking text \u003ccode\u003e_italicized_\u003c/code\u003e (\u003ccode\u003e\u0026#x3C;i\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eMaking text \u003ccode\u003e*bold*\u003c/code\u003e (\u003ccode\u003e\u0026#x3C;b\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eStriking through ~\u003ccode\u003etext\u003c/code\u003e~ (\u003ccode\u003e\u0026#x3C;strike\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eAdding line breaks (\u003ccode\u003e\u0026#x3C;br\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eAdding \u003ccode\u003eone-line code blocks\u003c/code\u003e using the backtick character (\u003ccode\u003e\u0026#x3C;code\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eAdding unordered lists (line broken dashes) (\u003ccode\u003e\u0026#x3C;ul\u003e\u0026#x3C;li\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eAdding external links \u003ccode\u003e\u0026#x3C;[external link]|[display text]\u003e\u003c/code\u003e (\u003ccode\u003e\u0026#x3C;a\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAlso note that the Slack documentation says that \u003ca href=\"https://api.slack.com/reference/surfaces/formatting#escaping\"\u003ecertain characters need to be escaped\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThere are a few more styles that could be implemented, but we'll focus on just this list for this post.\u003c/p\u003e\n\u003cp\u003eTo do this, we will utilize the \u003ca href=\"https://docs.python.org/3/library/html.html\"\u003e\u003ccode\u003ehtml\u003c/code\u003e\u003c/a\u003e module in the Python standard library to parse HTML tags, attributes, and values.\u003c/p\u003e\n\u003cp\u003eLet's write a class (we need to inherit functions for the \u003ccode\u003eHTMLParser\u003c/code\u003e class) where we will parse all of the tags and attributes, and escape the message text when needed.  The idea here is that we can construct a string from scratch and for each tag we care about we can \"replace\" the HTML tags with the relevant mrkdwn syntax.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom html.parser import HTMLParser\nimport re\nfrom typing import Any, List, Tuple\n\n\nclass SlackHTMLParser(HTMLParser):\n    def __init__(self, *args, **kwargs):\n        \"\"\"Escapes and converts an HTML string to Slack flavored\n        Markdown (mrkdwn).\n\n        More about Slack's Markdown Flavor (mrkdwn) can be seen here:\n            https://api.slack.com/reference/surfaces/formatting\n        \n        Call using `SlackHTMLParser(message_body).parse()`.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.slack_message = ''\n        self.ignore_tag = False  # Used to skip tags we don't care about\n        self.line_break = '::LINE::BREAK::'  # Unique sequence for swapping a \u0026#x3C;br\u003e\n\n\n    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Any]]):\n        \"\"\"Called when the opening of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n            attrs: List of tuples with the tuple having the following form:\n                (attribute name, value).  E.G. ('href', 'www.example.com').\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag in ['br', 'p', 'ul']:\n            self.slack_message += self.line_break\n        elif tag == 'li':\n            self.slack_message += f'{self.line_break}- '\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            href = [x[1] for x in attrs if x[0] == 'href']\n            if len(href) \u003e 0:\n                self.slack_message += f'\u0026#x3C;{href[0]}|'\n        else:\n            self.ignore_tag = True\n\n\n    def handle_data(self, data: str):\n        \"\"\"Handles the data within a tag.\n\n        This is called after `handle_starttag` and before `handle_endtag`.\n\n        We will also escape the following text per Slack's documentation:\n        - '\u0026#x26;' -\u003e '\u0026#x26;amp;'\n        - '\u0026#x3C;' -\u003e '\u0026#x26;lt;'\n        - '\u003e' -\u003e '\u0026#x26;gt;'\n\n        Args:\n            data: The data/string within the HTML tag.\n        \"\"\"\n        if not self.ignore_tag:\n            self.slack_message += data\\\n                .replace('\u0026#x26;', '\u0026#x26;amp;')\\\n                .replace('\u0026#x3C;', '\u0026#x26;lt;')\\\n                .replace('\u003e', '\u0026#x26;gt;')\n\n\n    def handle_endtag(self, tag: str):\n        \"\"\"Called when the closing of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.  This is basically the same as the handle_starttag.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag == 'p':\n            self.slack_message += self.line_break\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            self.slack_message += '\u003e'\n        \n        self.ignore_tag = False\n\n\n    def parse(self, html_string: str) -\u003e str:\n        \"\"\"Parses a given HTML string and applies simple formatting.\n        \n        Note that we need to apply the line break replacing here\n        instead of with the handle tag methods.\n\n        Args:\n            html_string: The HTML string to convert to Slack mrkdwn.\n\n        Returns:\n            A formatted Slack mrkdwn string.\n        \"\"\"\n        self.feed(html_string)\n        return re.sub(\n            r'^(\\n)+',  # Remove the leading line breaks\n            '',\n            ' '.join(self.slack_message.split()).replace(self.line_break, '\\n')\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can test our class out with the following code.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehtml_string = '''\n    \u0026#x3C;p\u003e\n        Here \u0026#x3C;i\u003eis\u0026#x3C;/i\u003e a \u0026#x3C;strike\u003eparagraph\u0026#x3C;/strike\u003e with a \u0026#x3C;b\u003elot\u0026#x3C;/b\u003e of formatting.\n    \u0026#x3C;/p\u003e\n    \u0026#x3C;br\u003e\n    \u0026#x3C;code\u003eCode sample\u0026#x3C;/code\u003e \u0026#x26; testing escape.\n    \u0026#x3C;ul\u003e\n        \u0026#x3C;li\u003e\n            \u0026#x3C;a href=\"https://www.google.com\"\u003eGoogle\u0026#x3C;/a\u003e\n        \u0026#x3C;/li\u003e\n        \u0026#x3C;li\u003e\n            \u0026#x3C;a href=\"https://www.amazon.com\"\u003eAmazon\u0026#x3C;/a\u003e\n        \u0026#x3C;/li\u003e\n    \u0026#x3C;/ul\u003e\n'''\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nprint(slack_message)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can test our formatter in an actual Slack message!  Import your formatter class or add it to your existing code so you're able to do the following.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehtml_string = '''\n    \u0026#x3C;p\u003e\n        Here \u0026#x3C;i\u003eis\u0026#x3C;/i\u003e a \u0026#x3C;strike\u003eparagraph\u0026#x3C;/strike\u003e with a \u0026#x3C;b\u003elot\u0026#x3C;/b\u003e of formatting.\n    \u0026#x3C;/p\u003e\n    \u0026#x3C;br\u003e\n    \u0026#x3C;code\u003eCode sample\u0026#x3C;/code\u003e \u0026#x26; testing escape.\n    \u0026#x3C;ul\u003e\n        \u0026#x3C;li\u003e\n            \u0026#x3C;a href=\"https://www.google.com\"\u003eGoogle\u0026#x3C;/a\u003e\n        \u0026#x3C;/li\u003e\n        \u0026#x3C;li\u003e\n            \u0026#x3C;a href=\"https://www.amazon.com\"\u003eAmazon\u0026#x3C;/a\u003e\n        \u0026#x3C;/li\u003e\n    \u0026#x3C;/ul\u003e\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou should see the following message in your notifications channel.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/slack-format-message.jpg\" alt=\"Second message in Slack {680x140}\"\u003e\u003c/p\u003e\n\u003cp\u003eLooks pretty good!  \u003cem\u003eNote that you can still send plain text messages, you don't need to use HTML.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eFor some final adjustments, you may have noticed that the message preview on the notification that popped up showed the actual \u003ccode\u003emrkdwn\u003c/code\u003e characters as opposed to a formatted notification.  This looks a little sloppy, so let's make a new notification title that is similar to an email subject line.\u003c/p\u003e\n\u003cp\u003eWe will briefly look at the basics of Slack's \u003ca href=\"https://api.slack.com/block-kit\"\u003eBlock Kit\u003c/a\u003e, which is a powerful way to add lots of customization to your Slack messages.  You can also explore Block Kit with Slack's \u003ca href=\"https://app.slack.com/block-kit-builder/\"\u003eBlock Kit Builder\u003c/a\u003e which provides a preview of your Slack message.\u003c/p\u003e\n\u003cp\u003eWithout diving too much into the details on the Block Kit, let's update our \u003ccode\u003eSlackWebhookBot\u003c/code\u003e class and add a method that adds a title block and a body block for our message.  Our subject line will appear in the notification itself, and also in the actual Slack message.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Add the `Dict` typing import to the existing typing imports\nfrom typing import Dict\n\ndef format_message(self, subject: str, body: str) -\u003e Dict:\n    \"\"\"Formats the subject and message body into Slack blocks.\n\n    Args:\n        subject: Subject that will appear on the notification popup.\n        body: The full message body.\n\n    Returns:\n        A dictionary payload with Slack block formatting.\n    \"\"\"\n    return {\n        'text': subject,\n        'blocks': [\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': f'*{subject}*',\n                },\n            },\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': body,\n                },\n            },\n        ],\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can tweak our \u003ccode\u003esend\u003c/code\u003e method to format a new message and accept a subject string as a Kwarg.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef send(self, message: str, subject: str = 'New message!') -\u003e bool:\n    \"\"\"Sends a formatted message to the webhook URL.\n\n    Args:\n        message: Plain text string to send to Slack.\n\n    Kwargs:\n        subject: The subject of the message that will appear in the notification\n            preview.\n\n    Returns:\n        A boolean representing if the request was successful.\n    \"\"\"\n    success = False\n    payload = self.format_message(subject, message)\n    try:\n        r = requests.post(\n            self.webhook_url,\n            headers=self.headers,\n            json=payload,\n            timeout=self.timeout\n        )\n    except requests.Timeout:\n        logger.error('Timeout occurred when trying to send message to Slack.')\n    except requests.RequestException as e:\n        logger.error(f'Error occurred when communicating with Slack: {e}.')\n    else:\n        success = True\n        logger.info('Successfully sent message to Slack.')\n\n    return success\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd we can test our notification with a new subject line.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehtml_string = '''\n    \u0026#x3C;p\u003e\n        Here \u0026#x3C;i\u003eis\u0026#x3C;/i\u003e a \u0026#x3C;strike\u003eparagraph\u0026#x3C;/strike\u003e with a \u0026#x3C;b\u003elot\u0026#x3C;/b\u003e of formatting.\n    \u0026#x3C;/p\u003e\n    \u0026#x3C;br\u003e\n    \u0026#x3C;code\u003eCode sample\u0026#x3C;/code\u003e \u0026#x26; testing escape.\n    \u0026#x3C;ul\u003e\n        \u0026#x3C;li\u003e\n            \u0026#x3C;a href=\"https://www.google.com\"\u003eGoogle\u0026#x3C;/a\u003e\n        \u0026#x3C;/li\u003e\n        \u0026#x3C;li\u003e\n            \u0026#x3C;a href=\"https://www.amazon.com\"\u003eAmazon\u0026#x3C;/a\u003e\n        \u0026#x3C;/li\u003e\n    \u0026#x3C;/ul\u003e\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message, subject='You\\'ve completed the tutorial!')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou should see a notification appear with the following preview\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/slack-popup.jpg\" alt=\"Slack notification {453x101}\"\u003e\u003c/p\u003e\n\u003cp\u003eand the following message in your channel.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slack-webhook/slack-last-message.jpg\" alt=\"Last message in Slack {680x159}\"\u003e\u003c/p\u003e\n\u003cp\u003eWe have a custom Slack notification app!  You can place the \u003ccode\u003esend\u003c/code\u003e message calls all across your applications with related messages and now you can have a better pulse on user activity that developers and any other employees/stakeholders can easily access.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eFor those wanting additional challenges or to continue developing their custom app, Slack has added a lot of really cool tools to the Block Kit.  There are a ton of really cool possibilities that can be added on by updating the \u003ccode\u003eformat_message\u003c/code\u003e method in our \u003ccode\u003eSlackWebhookBot\u003c/code\u003e class.\u003c/p\u003e\n\u003cp\u003eExplore the Slack's \u003ca href=\"https://app.slack.com/block-kit-builder/\"\u003eBlock Kit Builder\u003c/a\u003e and see what you can make!\u003c/p\u003e\n\u003chr\u003e\n","markdown":"\n## tl;dr\n\n### Goal\n_To set up a Slack webhook so we can send text and simple HTML notifications to receive in a Slack channel._\n\n### Process Overview\n1. Setting up a Slack webhook URL in your Slack workspace to post to a channel\n2. Posting a notification to our webhook\n3. Creating a simple HTML parser to match the custom Slack markdown flavor\n\n### Python Dependencies\n```python\n# Python standard library\nfrom html.parser import HTMLParser\nimport logging\nimport os\nimport re\nfrom typing import Any, List, Tuple\n\n# 3rd Party\nimport requests\n```\n\n### Assumptions\nI'll assume you have a Slack account, a Slack workspace setup, Slack is installed, and you have knowledge of Python with a basic understanding of webhooks.\n\n---\n\nIf you haven't heard of it before, [Slack](https://slack.com/) is a very popular team/workplace communication tool.  In addition to direct messaging, it allows you to separate discussion into various topics or **channels** for more focused team communication.\n\nAnother great feature of Slack is that you can add 3rd party [apps](https://slack.com/apps) (or integrations) from your existing stack, or even develop your own!  I have seen this streamline my own productivity, and I personally use a number of Slack apps.\n\nTo name a few, you may want to check out the following (assuming you use these tools) which I've found a lot of value in:\n- [Sentry](https://slack.com/apps/A011MFBJEUU-sentry?tab=more_info) - for application monitoring\n- [Google Calendar](https://slack.com/apps/ADZ494LHY-google-calendar?tab=more_info) - to stay on top of my meetings schedule\n- [GitHub](https://slack.com/apps/A01BP7R4KNY-github?tab=more_info) - getting notified of pull requests and meaningful changes to important repositories\n- [Jira Cloud](https://slack.com/apps/A2RPP3NFR-jira-cloud?tab=more_info) - staying on top of changes to Jira tickets\n- [AWS Chatbot](https://slack.com/apps/A6L22LZNH-aws-chatbot?tab=more_info) - alerts from CloudWatch alarms\n\nYou can browse the [Slack app directory](https://slack.com/apps) for more integrations.\n\nHowever, not every integration is going to provide the functionality you need.  This post will focus on creating our own custom Slack app with the goal of posting simple notifications to a Slack channel.\n\nA common use case where we can apply our app will be sending notifications when any sort of user activity happens on a platform.  As a developer, being notified of when a user completes a certain task can provide a lot of transparency and understanding into the usage of our application, while also keeping a sales teams informed on relevant activity on the platform.  This is the use case we'll focus on.\n\nWe will do this by posting to a webhook hosted by Slack.  For more information on webhooks, you can check out [this article](https://zapier.com/blog/what-are-webhooks/) by Zapier.\n\nLet's get started!\n\n---\n\n## Setting up the Slack App\nOpen Slack, click **Add channels**, and create a new channel called `notifications`.  This is where our Slack app will post to once we set it up.\n\n![Create a Slack channel {priority}{1004x580}](/images/slack-webhook/create-channel.jpg)\n\nNow go to a web browser and head to https://api.slack.com/apps/.\n\nClick on **Create an App**\n\n![Create a Slack App {1004x497}](/images/slack-webhook/create-app.jpg)\n\nSelect **From scratch**\n\n![Select From Scratch {1004x497}](/images/slack-webhook/from-scratch.jpg)\n\nCreate a name for your app and select the workspace you just created your `notifications` channel in.\n\n![Choose an app name and workspace {1004x501}](/images/slack-webhook/app-and-workspace.jpg)\n\n\nThis will redirect you to the **Basic Information** tab for your app.  Here, we'll enable **Incoming Webhooks**.  As it states, this will enable us to post messages from an external source.  In this case, our platform.\n\n![Enable incoming webhooks {1004x497}](/images/slack-webhook/add-webhooks.jpg)\n\n\nTurn on **Activate Incoming Webhooks** and you will see additional details appear.  Towards the bottom, click on **Add New Webhook to Workspace**.\n\n![Add a new webhook to your workspace {1004x485}](/images/slack-webhook/add-new-webhook.jpg)\n\nYou will be redirected again to select which channel to post to.  Select the `notifications` channel that we previously created and press **Allow**.\n\n![Select a channel for your app {1004x498}](/images/slack-webhook/choose-channel.jpg)\n\n\nThis will redirect you back to your app configuration and you will see a webhook URL you can now post to.  This will also include a simple curl POST request you can test with if you'd like.  Copy the webhook URL for later, and remember to **keep it private**.  This is a public URL that anyone can post to.\n\n![Copy your webhook URL {680x506}](/images/slack-webhook/copy-url.jpg)\n\n\nYou can return to the **Basic Information** of your app settings in Slack to view more API credentials and also edit the look and feel of your new Slack bot.\n\nNow we're ready to dive into the code to communicate with our webhook!\n\n---\n\n## Communicating with our Webhook\nTo communicate with our webhook, we'll use the [`requests`](https://docs.python-requests.org/en/master/) Python library.  This is a third party library, so you'll want to have a Python virtual environment set up to handle your dependencies.  Virtual environments are out of the scope of this article, but you can read more on them [here](https://docs.python.org/3/tutorial/venv.html).\n\nInside your virtual environment, you can run the following to install the library.\n```bash\npip install requests\n```\n\nNow, we'll set up a class to communicate with our Slack endpoint.  We'll start by just sending a plain text message to Slack.\n\n```python\nimport logging\n\nimport requests\n\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\nclass SlackWebhookBot:\n    def __init__(self, webhook_url: str, timeout: int = 15):\n        \"\"\"Class to send messages to a provided Slack webhook URL.\n\n        You can read more about Slack's Incoming Webhooks here:\n            https://api.slack.com/messaging/webhooks\n        \n        Args:\n            webhook_url: The webhook URL to send a message to.  Typically\n                formatted like \"https://hooks.slack.com/services/...\".\n        \n        Kwargs:\n            timeout: Number of seconds before the request will timeout.\n                This is used to prevent a hang and is set to a default\n                value of 15 seconds.\n        \"\"\"\n        self.webhook_url = webhook_url\n        self.timeout = timeout\n        self.headers = {\n            'Content-Type': 'application/json',\n        }\n    \n\n    def send(self, message: str) -\u003e bool:\n        \"\"\"Sends a message to the webhook URL.\n\n        Per the Slack Incoming Webhook example.  The body of the request\n        (for plain text) should be formatted as follows:\n            `{\"text\": \"Hello, World!\"}`\n\n        Args:\n            message: Plain text string to send to Slack.\n\n        Returns:\n            A boolean representing if the request was successful.\n        \"\"\"\n        success = False\n        payload = {\n            'text': message,\n        }\n        try:\n            r = requests.post(\n                self.webhook_url,\n                headers=self.headers,\n                json=payload,\n                timeout=self.timeout\n            )\n        except requests.Timeout:\n            logger.error('Timeout occurred when trying to send message to Slack.')\n        except requests.RequestException as e:\n            logger.error(f'Error occurred when communicating with Slack: {e}.')\n        else:\n            success = True\n            logger.info('Successfully sent message to Slack.')\n\n        return success\n```\n\nAbove is the basic setup for communicating with the Slack webhook.  We can run a quick test by moving this code to a script and adding the following.\n```python\nimport os\n\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nslack = SlackWebhookBot(webhook_url)\nslack.send('Hello, world!')\n```\n\nMake sure to set your Slack webhook URL to the `SLACK_WEBHOOK_URL` environment variable, and make sure you're in your virtual environment with the `requests` package installed before running the script.  This can be done on MacOS with the following.\n```bash\nexport SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...\npython slack_webhook.py\n```\n\nWhen you run this, you should see a message from you Slack bot appear in the `notifications` channel!\n\n![Hello world message in Slack {1004x675}](/images/slack-webhook/slack-first-message.jpg)\n\n\nFor our notifications to be more helpful, we may want to add links or other formatting.  To do this, we will write our notifications with HTML tags, and then parse these tags and convert them to the [Slack flavored Markdown](https://api.slack.com/reference/surfaces/formatting) called `mrkdwn`.\n\n---\n\n## Adding a simple HTML parser to our class\nFrom the [Slack formatting guide](https://api.slack.com/reference/surfaces/formatting) for messages, we can see all of the ways to format text in our messages.  For our purposes, we will focus on a primary list.\n\n- Making text \u003ci\u003e`_italicized_`\u003c/i\u003e (`\u003ci\u003e`)\n- Making text \u003cb\u003e`*bold*`\u003c/b\u003e (`\u003cb\u003e`)\n- Striking through ~\u003cstrike\u003e`text`\u003c/strike\u003e~ (`\u003cstrike\u003e`)\n- Adding line breaks (`\u003cbr\u003e`)\n- Adding `one-line code blocks` using the backtick character (`\u003ccode\u003e`)\n- Adding unordered lists (line broken dashes) (`\u003cul\u003e\u003cli\u003e`)\n- Adding external links `\u003c[external link]|[display text]\u003e` (`\u003ca\u003e`)\n\nAlso note that the Slack documentation says that [certain characters need to be escaped](https://api.slack.com/reference/surfaces/formatting#escaping).\n\nThere are a few more styles that could be implemented, but we'll focus on just this list for this post.\n\nTo do this, we will utilize the [`html`](https://docs.python.org/3/library/html.html) module in the Python standard library to parse HTML tags, attributes, and values.\n\nLet's write a class (we need to inherit functions for the `HTMLParser` class) where we will parse all of the tags and attributes, and escape the message text when needed.  The idea here is that we can construct a string from scratch and for each tag we care about we can \"replace\" the HTML tags with the relevant mrkdwn syntax.\n\n```python\nfrom html.parser import HTMLParser\nimport re\nfrom typing import Any, List, Tuple\n\n\nclass SlackHTMLParser(HTMLParser):\n    def __init__(self, *args, **kwargs):\n        \"\"\"Escapes and converts an HTML string to Slack flavored\n        Markdown (mrkdwn).\n\n        More about Slack's Markdown Flavor (mrkdwn) can be seen here:\n            https://api.slack.com/reference/surfaces/formatting\n        \n        Call using `SlackHTMLParser(message_body).parse()`.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.slack_message = ''\n        self.ignore_tag = False  # Used to skip tags we don't care about\n        self.line_break = '::LINE::BREAK::'  # Unique sequence for swapping a \u003cbr\u003e\n\n\n    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Any]]):\n        \"\"\"Called when the opening of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n            attrs: List of tuples with the tuple having the following form:\n                (attribute name, value).  E.G. ('href', 'www.example.com').\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag in ['br', 'p', 'ul']:\n            self.slack_message += self.line_break\n        elif tag == 'li':\n            self.slack_message += f'{self.line_break}- '\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            href = [x[1] for x in attrs if x[0] == 'href']\n            if len(href) \u003e 0:\n                self.slack_message += f'\u003c{href[0]}|'\n        else:\n            self.ignore_tag = True\n\n\n    def handle_data(self, data: str):\n        \"\"\"Handles the data within a tag.\n\n        This is called after `handle_starttag` and before `handle_endtag`.\n\n        We will also escape the following text per Slack's documentation:\n        - '\u0026' -\u003e '\u0026amp;'\n        - '\u003c' -\u003e '\u0026lt;'\n        - '\u003e' -\u003e '\u0026gt;'\n\n        Args:\n            data: The data/string within the HTML tag.\n        \"\"\"\n        if not self.ignore_tag:\n            self.slack_message += data\\\n                .replace('\u0026', '\u0026amp;')\\\n                .replace('\u003c', '\u0026lt;')\\\n                .replace('\u003e', '\u0026gt;')\n\n\n    def handle_endtag(self, tag: str):\n        \"\"\"Called when the closing of a tag is encountered.\n\n        The idea here is to swap out the tag with the respective mrkdwn\n        symbol.  This is basically the same as the handle_starttag.\n\n        Args:\n            tag: Lowercase name of the HTML tag.  E.G. `br` or `i`.\n        \"\"\"\n        if tag in ['i', 'em']:\n            self.slack_message += '_'\n        elif tag in ['b', 'strong']:\n            self.slack_message += '*'\n        elif tag == 'strike':\n            self.slack_message += '~'\n        elif tag == 'p':\n            self.slack_message += self.line_break\n        elif tag == 'code':\n            self.slack_message += '`'\n        elif tag == 'a':\n            self.slack_message += '\u003e'\n        \n        self.ignore_tag = False\n\n\n    def parse(self, html_string: str) -\u003e str:\n        \"\"\"Parses a given HTML string and applies simple formatting.\n        \n        Note that we need to apply the line break replacing here\n        instead of with the handle tag methods.\n\n        Args:\n            html_string: The HTML string to convert to Slack mrkdwn.\n\n        Returns:\n            A formatted Slack mrkdwn string.\n        \"\"\"\n        self.feed(html_string)\n        return re.sub(\n            r'^(\\n)+',  # Remove the leading line breaks\n            '',\n            ' '.join(self.slack_message.split()).replace(self.line_break, '\\n')\n        )\n```\n\nWe can test our class out with the following code.\n\n```python\nhtml_string = '''\n    \u003cp\u003e\n        Here \u003ci\u003eis\u003c/i\u003e a \u003cstrike\u003eparagraph\u003c/strike\u003e with a \u003cb\u003elot\u003c/b\u003e of formatting.\n    \u003c/p\u003e\n    \u003cbr\u003e\n    \u003ccode\u003eCode sample\u003c/code\u003e \u0026 testing escape.\n    \u003cul\u003e\n        \u003cli\u003e\n            \u003ca href=\"https://www.google.com\"\u003eGoogle\u003c/a\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\n            \u003ca href=\"https://www.amazon.com\"\u003eAmazon\u003c/a\u003e\n        \u003c/li\u003e\n    \u003c/ul\u003e\n'''\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nprint(slack_message)\n```\n\nNow we can test our formatter in an actual Slack message!  Import your formatter class or add it to your existing code so you're able to do the following.\n\n```python\nhtml_string = '''\n    \u003cp\u003e\n        Here \u003ci\u003eis\u003c/i\u003e a \u003cstrike\u003eparagraph\u003c/strike\u003e with a \u003cb\u003elot\u003c/b\u003e of formatting.\n    \u003c/p\u003e\n    \u003cbr\u003e\n    \u003ccode\u003eCode sample\u003c/code\u003e \u0026 testing escape.\n    \u003cul\u003e\n        \u003cli\u003e\n            \u003ca href=\"https://www.google.com\"\u003eGoogle\u003c/a\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\n            \u003ca href=\"https://www.amazon.com\"\u003eAmazon\u003c/a\u003e\n        \u003c/li\u003e\n    \u003c/ul\u003e\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message)\n```\n\nYou should see the following message in your notifications channel.\n\n![Second message in Slack {680x140}](/images/slack-webhook/slack-format-message.jpg)\n\nLooks pretty good!  _Note that you can still send plain text messages, you don't need to use HTML._\n\nFor some final adjustments, you may have noticed that the message preview on the notification that popped up showed the actual `mrkdwn` characters as opposed to a formatted notification.  This looks a little sloppy, so let's make a new notification title that is similar to an email subject line.\n\nWe will briefly look at the basics of Slack's [Block Kit](https://api.slack.com/block-kit), which is a powerful way to add lots of customization to your Slack messages.  You can also explore Block Kit with Slack's [Block Kit Builder](https://app.slack.com/block-kit-builder/) which provides a preview of your Slack message.\n\nWithout diving too much into the details on the Block Kit, let's update our `SlackWebhookBot` class and add a method that adds a title block and a body block for our message.  Our subject line will appear in the notification itself, and also in the actual Slack message.\n\n```python\n# Add the `Dict` typing import to the existing typing imports\nfrom typing import Dict\n\ndef format_message(self, subject: str, body: str) -\u003e Dict:\n    \"\"\"Formats the subject and message body into Slack blocks.\n\n    Args:\n        subject: Subject that will appear on the notification popup.\n        body: The full message body.\n\n    Returns:\n        A dictionary payload with Slack block formatting.\n    \"\"\"\n    return {\n        'text': subject,\n        'blocks': [\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': f'*{subject}*',\n                },\n            },\n            {\n                'type': 'section',\n                'text': {\n                    'type': 'mrkdwn',\n                    'text': body,\n                },\n            },\n        ],\n    }\n```\n\nNow we can tweak our `send` method to format a new message and accept a subject string as a Kwarg.\n\n```python\ndef send(self, message: str, subject: str = 'New message!') -\u003e bool:\n    \"\"\"Sends a formatted message to the webhook URL.\n\n    Args:\n        message: Plain text string to send to Slack.\n\n    Kwargs:\n        subject: The subject of the message that will appear in the notification\n            preview.\n\n    Returns:\n        A boolean representing if the request was successful.\n    \"\"\"\n    success = False\n    payload = self.format_message(subject, message)\n    try:\n        r = requests.post(\n            self.webhook_url,\n            headers=self.headers,\n            json=payload,\n            timeout=self.timeout\n        )\n    except requests.Timeout:\n        logger.error('Timeout occurred when trying to send message to Slack.')\n    except requests.RequestException as e:\n        logger.error(f'Error occurred when communicating with Slack: {e}.')\n    else:\n        success = True\n        logger.info('Successfully sent message to Slack.')\n\n    return success\n```\n\nAnd we can test our notification with a new subject line.\n\n```python\nhtml_string = '''\n    \u003cp\u003e\n        Here \u003ci\u003eis\u003c/i\u003e a \u003cstrike\u003eparagraph\u003c/strike\u003e with a \u003cb\u003elot\u003c/b\u003e of formatting.\n    \u003c/p\u003e\n    \u003cbr\u003e\n    \u003ccode\u003eCode sample\u003c/code\u003e \u0026 testing escape.\n    \u003cul\u003e\n        \u003cli\u003e\n            \u003ca href=\"https://www.google.com\"\u003eGoogle\u003c/a\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\n            \u003ca href=\"https://www.amazon.com\"\u003eAmazon\u003c/a\u003e\n        \u003c/li\u003e\n    \u003c/ul\u003e\n'''\nwebhook_url = os.environ.get('SLACK_WEBHOOK_URL')\nparser = SlackHTMLParser()\nslack_message = parser.parse(html_string)\nslack = SlackWebhookBot(webhook_url)\nslack.send(slack_message, subject='You\\'ve completed the tutorial!')\n```\n\nYou should see a notification appear with the following preview\n\n![Slack notification {453x101}](/images/slack-webhook/slack-popup.jpg)\n\n\nand the following message in your channel.\n\n![Last message in Slack {680x159}](/images/slack-webhook/slack-last-message.jpg)\n\n\nWe have a custom Slack notification app!  You can place the `send` message calls all across your applications with related messages and now you can have a better pulse on user activity that developers and any other employees/stakeholders can easily access.\n\n---\n\nFor those wanting additional challenges or to continue developing their custom app, Slack has added a lot of really cool tools to the Block Kit.  There are a ton of really cool possibilities that can be added on by updating the `format_message` method in our `SlackWebhookBot` class.\n\nExplore the Slack's [Block Kit Builder](https://app.slack.com/block-kit-builder/) and see what you can make!\n\n---\n","title":"Setting up a Slack webhook for simple notifications","date":"2021-07-11","tags":["python","slack","webhook","api"],"description":"Setting up a Slack webhook to send plain text or simple HTML notifications to a Slack channel."}]},"__N_SSG":true},"page":"/tags/[tag]","query":{"tag":"api"},"buildId":"Od_YqLWoiun7axqz_XJ1D","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>